{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CLEUR 2020 DEVWKS-1407 Please use the navigation on the left to move between exercises, starting with 00-Setup.","title":"Overview"},{"location":"#welcome-to-cleur-2020-devwks-1407","text":"Please use the navigation on the left to move between exercises, starting with 00-Setup.","title":"Welcome to CLEUR 2020 DEVWKS-1407"},{"location":"00-setup/","text":"Bringing up the Topology Overview We have created a setup on this laptop you are sitting in front of which consists of a CXTA docker container containing the Python runtime environment to execute the tests two virtual IOS-XE devices which serve as units-under-test (UUT) The setup is depicted in the below diagram. Start the Environment To start the environment, please execute the following commands from your Linux shell: 1 2 cd xxx / DEVWKS - 1407 . / start - routers . sh This shell script performs the following tasks: It uses Vagrant to bring up the two IOS-XE virtual routers (using Virtualbox) Performs an initial configuration of the devices (essentially setting the hostname and configures IPv4/IPv6 on the link between the devices) Creates a testbed.yaml file which contains the device credentials and SSH ports to connect to the two virtual devices Starts the CXTA container (using docker-compose) As a final step, a Robot/CXTA test is run which verifies the basic connectivity. If all went well, the script output should end with below: 1 2 3 4 5 6 7 8 9 10 ============================================================================== Test - Vms ============================================================================== connect to all devices | PASS | Connected to [ ' r1 ' , ' r2 ' ] ------------------------------------------------------------------------------ Test - Vms | PASS | 1 critical test , 1 passed , 0 failed 1 test total , 1 passed , 0 failed ============================================================================== If the test shows an error, it typically points to an issue bringing up the VM. Please refer to the next paragraph for some troubleshooting guidance. Please check for a full output of a working startup at the end of this page . Please move on to the next chapter to create and execute your first test case. Troubleshooting the Start You should first check if both VMs are up and running using the vagrant status command. You should see two VMs running: 1 2 3 4 5 $ vagrant status Current machine states: r1 running ( virtualbox ) r2 running ( virtualbox ) If this is not the case, please try to re-execute the ./start-routers.sh script from above. If this still fails, please kill the VMs before trying again: 1 2 3 4 5 $ vagrant destroy -f [ ... ] $ ./start-routers.sh If both VMs show up as running , you should be able to ssh into them, using the vagrant ssh xx command (replacing xx by the router name, i.e. r1 or r2): 1 2 3 4 [ devnet@oli-test-w CLEUR20-CXTA ] $ vagrant ssh r1 r1 # You can then verify the connectivity between the two routers via the direct connection, for example by checking the routing adjacency (using show ip ospf neighbor ), you should see one neighbour: 1 2 3 4 5 r1 # show ip ospf neighbor Neighbor ID Pri State Dead Time Address Interface 10 . 0 . 0 . 2 1 FULL / BDR 00 : 00 : 38 172 . 16 . 0 . 2 GigabitEthernet2 r1 # Use exit to exit from the device(s). Appendix: Sample Startup Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 $ . / start - routers . sh Bringing machine ' r1 ' up with ' virtualbox ' provider ... ==> r1 : Clearing any previously set forwarded ports ... ==> r1 : Clearing any previously set network interfaces ... ==> r1 : Preparing network interfaces based on configuration ... r1 : Adapter 1 : nat r1 : Adapter 2 : intnet r1 : Adapter 3 : intnet ==> r1 : Forwarding ports ... r1 : 830 ( guest ) => 2223 ( host ) ( adapter 1 ) r1 : 80 ( guest ) => 2224 ( host ) ( adapter 1 ) r1 : 443 ( guest ) => 2225 ( host ) ( adapter 1 ) r1 : 8443 ( guest ) => 2226 ( host ) ( adapter 1 ) r1 : 22 ( guest ) => 2222 ( host ) ( adapter 1 ) ==> r1 : Running ' pre-boot ' VM customizations ... ==> r1 : Booting VM ... ==> r1 : Waiting for machine to boot . This may take a few minutes ... r1 : SSH address : 127 . 0 . 0 . 1 : 2222 r1 : SSH username : vagrant r1 : SSH auth method : private key ==> r1 : Machine booted and ready ! ==> r1 : Checking for guest additions in VM ... r1 : No guest additions were detected on the base box for this VM ! Guest r1 : additions are required for forwarded ports , shared folders , host only r1 : networking , and more . If SSH fails on this machine , please install r1 : the guest additions and repackage the box to continue . r1 : r1 : This is not an error message ; everything may continue to work properly, r1 : in which case you may ignore this message . ==> r1 : Machine already provisioned . Run ` vagrant provision ` or use the ` -- provision ` ==> r1 : flag to force provisioning . Provisioners marked to run always will still run . ==> r1 : Machine ' r1 ' has a post ` vagrant up ` message . This is a message ==> r1 : from the creator of the Vagrantfile , and not from Vagrant itself : ==> r1 : ==> r1 : ==> r1 : Welcome to the IOS XE VirtualBox . ==> r1 : To connect to the XE via ssh , use : ' vagrant ssh ' . ==> r1 : To ssh to XE ' s NETCONF or RESTCONF agent, use: ==> r1 : ' vagrant port ' ( vagrant version > 1 . 8 ) ==> r1 : to determine the port that maps to the guestport , ==> r1 : ==> r1 : The password for the vagrant user is vagrant ==> r1 : ==> r1 : IMPORTANT : READ CAREFULLY ==> r1 : The Software is subject to and governed by the terms and conditions ==> r1 : of the End User License Agreement and the Supplemental End User ==> r1 : License Agreement accompanying the product , made available at the ==> r1 : time of your order , or posted on the Cisco website at ==> r1 : www . cisco . com / go / terms ( collectively , the ' Agreement ' ) . ==> r1 : As set forth more fully in the Agreement , use of the Software is ==> r1 : strictly limited to internal use in a non - production environment ==> r1 : solely for demonstration and evaluation purposes . Downloading , ==> r1 : installing , or using the Software constitutes acceptance of the ==> r1 : Agreement , and you are binding yourself and the business entity ==> r1 : that you represent to the Agreement . If you do not agree to all ==> r1 : of the terms of the Agreement , then Cisco is unwilling to license ==> r1 : the Software to you and ( a ) you may not download , install or use the ==> r1 : Software , and ( b ) you may return the Software as more fully set forth ==> r1 : in the Agreement . Bringing machine ' r2 ' up with ' virtualbox ' provider ... ==> r2 : Clearing any previously set forwarded ports ... ==> r2 : Fixed port collision for 830 => 2223 . Now on port 2200 . ==> r2 : Fixed port collision for 80 => 2224 . Now on port 2201 . ==> r2 : Fixed port collision for 443 => 2225 . Now on port 2202 . ==> r2 : Fixed port collision for 8443 => 2226 . Now on port 2203 . ==> r2 : Fixed port collision for 22 => 2222 . Now on port 2204 . ==> r2 : Clearing any previously set network interfaces ... ==> r2 : Preparing network interfaces based on configuration ... r2 : Adapter 1 : nat r2 : Adapter 2 : intnet r2 : Adapter 3 : intnet ==> r2 : Forwarding ports ... r2 : 830 ( guest ) => 2200 ( host ) ( adapter 1 ) r2 : 80 ( guest ) => 2201 ( host ) ( adapter 1 ) r2 : 443 ( guest ) => 2202 ( host ) ( adapter 1 ) r2 : 8443 ( guest ) => 2203 ( host ) ( adapter 1 ) r2 : 22 ( guest ) => 2204 ( host ) ( adapter 1 ) ==> r2 : Running ' pre-boot ' VM customizations ... ==> r2 : Booting VM ... ==> r2 : Waiting for machine to boot . This may take a few minutes ... r2 : SSH address : 127 . 0 . 0 . 1 : 2204 r2 : SSH username : vagrant r2 : SSH auth method : private key ==> r2 : Machine booted and ready ! ==> r2 : Checking for guest additions in VM ... r2 : No guest additions were detected on the base box for this VM ! Guest r2 : additions are required for forwarded ports , shared folders , host only r2 : networking , and more . If SSH fails on this machine , please install r2 : the guest additions and repackage the box to continue . r2 : r2 : This is not an error message ; everything may continue to work properly, r2 : in which case you may ignore this message . ==> r2 : Machine already provisioned . Run ` vagrant provision ` or use the ` -- provision ` ==> r2 : flag to force provisioning . Provisioners marked to run always will still run . ==> r2 : Machine ' r2 ' has a post ` vagrant up ` message . This is a message ==> r2 : from the creator of the Vagrantfile , and not from Vagrant itself : ==> r2 : ==> r2 : ==> r2 : Welcome to the IOS XE VirtualBox . ==> r2 : To connect to the XE via ssh , use : ' vagrant ssh ' . ==> r2 : To ssh to XE ' s NETCONF or RESTCONF agent, use: ==> r2 : ' vagrant port ' ( vagrant version > 1 . 8 ) ==> r2 : to determine the port that maps to the guestport , ==> r2 : ==> r2 : The password for the vagrant user is vagrant ==> r2 : ==> r2 : IMPORTANT : READ CAREFULLY ==> r2 : The Software is subject to and governed by the terms and conditions ==> r2 : of the End User License Agreement and the Supplemental End User ==> r2 : License Agreement accompanying the product , made available at the ==> r2 : time of your order , or posted on the Cisco website at ==> r2 : www . cisco . com / go / terms ( collectively , the ' Agreement ' ) . ==> r2 : As set forth more fully in the Agreement , use of the Software is ==> r2 : strictly limited to internal use in a non - production environment ==> r2 : solely for demonstration and evaluation purposes . Downloading , ==> r2 : installing , or using the Software constitutes acceptance of the ==> r2 : Agreement , and you are binding yourself and the business entity ==> r2 : that you represent to the Agreement . If you do not agree to all ==> r2 : of the terms of the Agreement , then Cisco is unwilling to license ==> r2 : the Software to you and ( a ) you may not download , install or use the ==> r2 : Software , and ( b ) you may return the Software as more fully set forth ==> r2 : in the Agreement . Setting up r1 r1 # conf term Enter configuration commands , one per line . End with CNTL / Z . r1 ( config ) # hostname r1 r1 ( config ) # ipv6 unicast - routing r1 ( config ) # no ip domain - lookup r1 ( config ) # default interface Loopback0 Interface Loopback0 set to default configuration r1 ( config ) # interface loopback0 r1 ( config - if ) # ip address 10 . 0 . 0 . 1 255 . 255 . 255 . 255 r1 ( config - if ) # ipv6 address fd00 : 0 : 0 : 0 :: 1 / 128 r1 ( config - if ) # ip ospf 1 area 0 r1 ( config - if ) # ipv6 ospf 1 area 0 r1 ( config - if ) # default interface GigabitEthernet2 Interface GigabitEthernet2 set to default configuration r1 ( config ) # interface GigabitEthernet2 r1 ( config - if ) # no shut r1 ( config - if ) # ip address 172 . 16 . 0 . 1 255 . 255 . 255 . 0 r1 ( config - if ) # ipv6 address fd00 : a : a : a : 2 :: 1 / 64 r1 ( config - if ) # ip ospf 1 area 0 r1 ( config - if ) # ipv6 ospf 1 area 0 r1 ( config - if ) # end r1 # write Building configuration ... [ OK ] r1 # exit Connection to 127 . 0 . 0 . 1 closed by remote host . Setting up r2 r2 # conf term Enter configuration commands , one per line . End with CNTL / Z . r2 ( config ) # hostname r2 r2 ( config ) # ipv6 unicast - routing r2 ( config ) # no ip domain - lookup r2 ( config ) # default interface Loopback0 Interface Loopback0 set to default configuration r2 ( config ) # interface loopback0 r2 ( config - if ) # ip address 10 . 0 . 0 . 2 255 . 255 . 255 . 255 r2 ( config - if ) # ipv6 address fd00 : 0 : 0 : 0 :: 2 / 128 r2 ( config - if ) # ip ospf 1 area 0 r2 ( config - if ) # ipv6 ospf 1 area 0 r2 ( config - if ) # default interface GigabitEthernet2 Interface GigabitEthernet2 set to default configuration r2 ( config ) # interface GigabitEthernet2 r2 ( config - if ) # no shut r2 ( config - if ) # ip address 172 . 16 . 0 . 2 255 . 255 . 255 . 0 r2 ( config - if ) # ipv6 address fd00 : a : a : a : 2 :: 2 / 64 r2 ( config - if ) # ip ospf 1 area 0 r2 ( config - if ) # ipv6 ospf 1 area 0 r2 ( config - if ) # end r2 # write Building configuration ... [ OK ] r2 # exit Connection to 127 . 0 . 0 . 1 closed by remote host . Setting up testbed . yaml r1 , 127 . 0 . 0 . 1 : 2222 , IdentityFile / home / devnet / . vagrant . d / insecure_private_key r2 , 127 . 0 . 0 . 1 : 2204 , IdentityFile / home / devnet / . vagrant . d / insecure_private_key starting cxta container Starting cxta_devnet ... done Starting cxta_docs ... done ============================================================================== Test - Vms ============================================================================== connect to all devices | PASS | Connected to [ ' r1 ' , ' r2 ' ] ------------------------------------------------------------------------------ Test - Vms | PASS | 1 critical test , 1 passed , 0 failed 1 test total , 1 passed , 0 failed ============================================================================== Output : / tmp / output . xml Log : / tmp / log . html Report : / tmp / report . html","title":"00 Setup"},{"location":"00-setup/#bringing-up-the-topology","text":"","title":"Bringing up the Topology"},{"location":"00-setup/#overview","text":"We have created a setup on this laptop you are sitting in front of which consists of a CXTA docker container containing the Python runtime environment to execute the tests two virtual IOS-XE devices which serve as units-under-test (UUT) The setup is depicted in the below diagram.","title":"Overview"},{"location":"00-setup/#start-the-environment","text":"To start the environment, please execute the following commands from your Linux shell: 1 2 cd xxx / DEVWKS - 1407 . / start - routers . sh This shell script performs the following tasks: It uses Vagrant to bring up the two IOS-XE virtual routers (using Virtualbox) Performs an initial configuration of the devices (essentially setting the hostname and configures IPv4/IPv6 on the link between the devices) Creates a testbed.yaml file which contains the device credentials and SSH ports to connect to the two virtual devices Starts the CXTA container (using docker-compose) As a final step, a Robot/CXTA test is run which verifies the basic connectivity. If all went well, the script output should end with below: 1 2 3 4 5 6 7 8 9 10 ============================================================================== Test - Vms ============================================================================== connect to all devices | PASS | Connected to [ ' r1 ' , ' r2 ' ] ------------------------------------------------------------------------------ Test - Vms | PASS | 1 critical test , 1 passed , 0 failed 1 test total , 1 passed , 0 failed ============================================================================== If the test shows an error, it typically points to an issue bringing up the VM. Please refer to the next paragraph for some troubleshooting guidance. Please check for a full output of a working startup at the end of this page . Please move on to the next chapter to create and execute your first test case.","title":"Start the Environment"},{"location":"00-setup/#troubleshooting-the-start","text":"You should first check if both VMs are up and running using the vagrant status command. You should see two VMs running: 1 2 3 4 5 $ vagrant status Current machine states: r1 running ( virtualbox ) r2 running ( virtualbox ) If this is not the case, please try to re-execute the ./start-routers.sh script from above. If this still fails, please kill the VMs before trying again: 1 2 3 4 5 $ vagrant destroy -f [ ... ] $ ./start-routers.sh If both VMs show up as running , you should be able to ssh into them, using the vagrant ssh xx command (replacing xx by the router name, i.e. r1 or r2): 1 2 3 4 [ devnet@oli-test-w CLEUR20-CXTA ] $ vagrant ssh r1 r1 # You can then verify the connectivity between the two routers via the direct connection, for example by checking the routing adjacency (using show ip ospf neighbor ), you should see one neighbour: 1 2 3 4 5 r1 # show ip ospf neighbor Neighbor ID Pri State Dead Time Address Interface 10 . 0 . 0 . 2 1 FULL / BDR 00 : 00 : 38 172 . 16 . 0 . 2 GigabitEthernet2 r1 # Use exit to exit from the device(s).","title":"Troubleshooting the Start"},{"location":"00-setup/#appendix-sample-startup-output","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 $ . / start - routers . sh Bringing machine ' r1 ' up with ' virtualbox ' provider ... ==> r1 : Clearing any previously set forwarded ports ... ==> r1 : Clearing any previously set network interfaces ... ==> r1 : Preparing network interfaces based on configuration ... r1 : Adapter 1 : nat r1 : Adapter 2 : intnet r1 : Adapter 3 : intnet ==> r1 : Forwarding ports ... r1 : 830 ( guest ) => 2223 ( host ) ( adapter 1 ) r1 : 80 ( guest ) => 2224 ( host ) ( adapter 1 ) r1 : 443 ( guest ) => 2225 ( host ) ( adapter 1 ) r1 : 8443 ( guest ) => 2226 ( host ) ( adapter 1 ) r1 : 22 ( guest ) => 2222 ( host ) ( adapter 1 ) ==> r1 : Running ' pre-boot ' VM customizations ... ==> r1 : Booting VM ... ==> r1 : Waiting for machine to boot . This may take a few minutes ... r1 : SSH address : 127 . 0 . 0 . 1 : 2222 r1 : SSH username : vagrant r1 : SSH auth method : private key ==> r1 : Machine booted and ready ! ==> r1 : Checking for guest additions in VM ... r1 : No guest additions were detected on the base box for this VM ! Guest r1 : additions are required for forwarded ports , shared folders , host only r1 : networking , and more . If SSH fails on this machine , please install r1 : the guest additions and repackage the box to continue . r1 : r1 : This is not an error message ; everything may continue to work properly, r1 : in which case you may ignore this message . ==> r1 : Machine already provisioned . Run ` vagrant provision ` or use the ` -- provision ` ==> r1 : flag to force provisioning . Provisioners marked to run always will still run . ==> r1 : Machine ' r1 ' has a post ` vagrant up ` message . This is a message ==> r1 : from the creator of the Vagrantfile , and not from Vagrant itself : ==> r1 : ==> r1 : ==> r1 : Welcome to the IOS XE VirtualBox . ==> r1 : To connect to the XE via ssh , use : ' vagrant ssh ' . ==> r1 : To ssh to XE ' s NETCONF or RESTCONF agent, use: ==> r1 : ' vagrant port ' ( vagrant version > 1 . 8 ) ==> r1 : to determine the port that maps to the guestport , ==> r1 : ==> r1 : The password for the vagrant user is vagrant ==> r1 : ==> r1 : IMPORTANT : READ CAREFULLY ==> r1 : The Software is subject to and governed by the terms and conditions ==> r1 : of the End User License Agreement and the Supplemental End User ==> r1 : License Agreement accompanying the product , made available at the ==> r1 : time of your order , or posted on the Cisco website at ==> r1 : www . cisco . com / go / terms ( collectively , the ' Agreement ' ) . ==> r1 : As set forth more fully in the Agreement , use of the Software is ==> r1 : strictly limited to internal use in a non - production environment ==> r1 : solely for demonstration and evaluation purposes . Downloading , ==> r1 : installing , or using the Software constitutes acceptance of the ==> r1 : Agreement , and you are binding yourself and the business entity ==> r1 : that you represent to the Agreement . If you do not agree to all ==> r1 : of the terms of the Agreement , then Cisco is unwilling to license ==> r1 : the Software to you and ( a ) you may not download , install or use the ==> r1 : Software , and ( b ) you may return the Software as more fully set forth ==> r1 : in the Agreement . Bringing machine ' r2 ' up with ' virtualbox ' provider ... ==> r2 : Clearing any previously set forwarded ports ... ==> r2 : Fixed port collision for 830 => 2223 . Now on port 2200 . ==> r2 : Fixed port collision for 80 => 2224 . Now on port 2201 . ==> r2 : Fixed port collision for 443 => 2225 . Now on port 2202 . ==> r2 : Fixed port collision for 8443 => 2226 . Now on port 2203 . ==> r2 : Fixed port collision for 22 => 2222 . Now on port 2204 . ==> r2 : Clearing any previously set network interfaces ... ==> r2 : Preparing network interfaces based on configuration ... r2 : Adapter 1 : nat r2 : Adapter 2 : intnet r2 : Adapter 3 : intnet ==> r2 : Forwarding ports ... r2 : 830 ( guest ) => 2200 ( host ) ( adapter 1 ) r2 : 80 ( guest ) => 2201 ( host ) ( adapter 1 ) r2 : 443 ( guest ) => 2202 ( host ) ( adapter 1 ) r2 : 8443 ( guest ) => 2203 ( host ) ( adapter 1 ) r2 : 22 ( guest ) => 2204 ( host ) ( adapter 1 ) ==> r2 : Running ' pre-boot ' VM customizations ... ==> r2 : Booting VM ... ==> r2 : Waiting for machine to boot . This may take a few minutes ... r2 : SSH address : 127 . 0 . 0 . 1 : 2204 r2 : SSH username : vagrant r2 : SSH auth method : private key ==> r2 : Machine booted and ready ! ==> r2 : Checking for guest additions in VM ... r2 : No guest additions were detected on the base box for this VM ! Guest r2 : additions are required for forwarded ports , shared folders , host only r2 : networking , and more . If SSH fails on this machine , please install r2 : the guest additions and repackage the box to continue . r2 : r2 : This is not an error message ; everything may continue to work properly, r2 : in which case you may ignore this message . ==> r2 : Machine already provisioned . Run ` vagrant provision ` or use the ` -- provision ` ==> r2 : flag to force provisioning . Provisioners marked to run always will still run . ==> r2 : Machine ' r2 ' has a post ` vagrant up ` message . This is a message ==> r2 : from the creator of the Vagrantfile , and not from Vagrant itself : ==> r2 : ==> r2 : ==> r2 : Welcome to the IOS XE VirtualBox . ==> r2 : To connect to the XE via ssh , use : ' vagrant ssh ' . ==> r2 : To ssh to XE ' s NETCONF or RESTCONF agent, use: ==> r2 : ' vagrant port ' ( vagrant version > 1 . 8 ) ==> r2 : to determine the port that maps to the guestport , ==> r2 : ==> r2 : The password for the vagrant user is vagrant ==> r2 : ==> r2 : IMPORTANT : READ CAREFULLY ==> r2 : The Software is subject to and governed by the terms and conditions ==> r2 : of the End User License Agreement and the Supplemental End User ==> r2 : License Agreement accompanying the product , made available at the ==> r2 : time of your order , or posted on the Cisco website at ==> r2 : www . cisco . com / go / terms ( collectively , the ' Agreement ' ) . ==> r2 : As set forth more fully in the Agreement , use of the Software is ==> r2 : strictly limited to internal use in a non - production environment ==> r2 : solely for demonstration and evaluation purposes . Downloading , ==> r2 : installing , or using the Software constitutes acceptance of the ==> r2 : Agreement , and you are binding yourself and the business entity ==> r2 : that you represent to the Agreement . If you do not agree to all ==> r2 : of the terms of the Agreement , then Cisco is unwilling to license ==> r2 : the Software to you and ( a ) you may not download , install or use the ==> r2 : Software , and ( b ) you may return the Software as more fully set forth ==> r2 : in the Agreement . Setting up r1 r1 # conf term Enter configuration commands , one per line . End with CNTL / Z . r1 ( config ) # hostname r1 r1 ( config ) # ipv6 unicast - routing r1 ( config ) # no ip domain - lookup r1 ( config ) # default interface Loopback0 Interface Loopback0 set to default configuration r1 ( config ) # interface loopback0 r1 ( config - if ) # ip address 10 . 0 . 0 . 1 255 . 255 . 255 . 255 r1 ( config - if ) # ipv6 address fd00 : 0 : 0 : 0 :: 1 / 128 r1 ( config - if ) # ip ospf 1 area 0 r1 ( config - if ) # ipv6 ospf 1 area 0 r1 ( config - if ) # default interface GigabitEthernet2 Interface GigabitEthernet2 set to default configuration r1 ( config ) # interface GigabitEthernet2 r1 ( config - if ) # no shut r1 ( config - if ) # ip address 172 . 16 . 0 . 1 255 . 255 . 255 . 0 r1 ( config - if ) # ipv6 address fd00 : a : a : a : 2 :: 1 / 64 r1 ( config - if ) # ip ospf 1 area 0 r1 ( config - if ) # ipv6 ospf 1 area 0 r1 ( config - if ) # end r1 # write Building configuration ... [ OK ] r1 # exit Connection to 127 . 0 . 0 . 1 closed by remote host . Setting up r2 r2 # conf term Enter configuration commands , one per line . End with CNTL / Z . r2 ( config ) # hostname r2 r2 ( config ) # ipv6 unicast - routing r2 ( config ) # no ip domain - lookup r2 ( config ) # default interface Loopback0 Interface Loopback0 set to default configuration r2 ( config ) # interface loopback0 r2 ( config - if ) # ip address 10 . 0 . 0 . 2 255 . 255 . 255 . 255 r2 ( config - if ) # ipv6 address fd00 : 0 : 0 : 0 :: 2 / 128 r2 ( config - if ) # ip ospf 1 area 0 r2 ( config - if ) # ipv6 ospf 1 area 0 r2 ( config - if ) # default interface GigabitEthernet2 Interface GigabitEthernet2 set to default configuration r2 ( config ) # interface GigabitEthernet2 r2 ( config - if ) # no shut r2 ( config - if ) # ip address 172 . 16 . 0 . 2 255 . 255 . 255 . 0 r2 ( config - if ) # ipv6 address fd00 : a : a : a : 2 :: 2 / 64 r2 ( config - if ) # ip ospf 1 area 0 r2 ( config - if ) # ipv6 ospf 1 area 0 r2 ( config - if ) # end r2 # write Building configuration ... [ OK ] r2 # exit Connection to 127 . 0 . 0 . 1 closed by remote host . Setting up testbed . yaml r1 , 127 . 0 . 0 . 1 : 2222 , IdentityFile / home / devnet / . vagrant . d / insecure_private_key r2 , 127 . 0 . 0 . 1 : 2204 , IdentityFile / home / devnet / . vagrant . d / insecure_private_key starting cxta container Starting cxta_devnet ... done Starting cxta_docs ... done ============================================================================== Test - Vms ============================================================================== connect to all devices | PASS | Connected to [ ' r1 ' , ' r2 ' ] ------------------------------------------------------------------------------ Test - Vms | PASS | 1 critical test , 1 passed , 0 failed 1 test total , 1 passed , 0 failed ============================================================================== Output : / tmp / output . xml Log : / tmp / log . html Report : / tmp / report . html","title":"Appendix: Sample Startup Output"},{"location":"01-basic/","text":"Basic Tests This Chapter introduces you to some basic Robotframework fundamentals and generic device interaction keywords. Test Execution Environment The Robotframework and CXTA runtime environment is installed on a pre-built Container, which has been started in the previous chapter . The directory structure containing the scripts and tests has been mounted into the container (into /home/devnet/cxta), so you can create/edit and examine files on the Linux operating system on the host (in XXXX/DEVWKS-1407/CLEUR2020-CXTA), while the execution happens on the container. Open an interactive session on the container using the following command: 1 docker exec - it cxta_devnet bash You will end up in the /home/devnet/cxta directory, and you can see all the files from the directory you started the environment from: 1 2 3 4 root @14 b56b5cc0ac : / home / devnet / cxta # ls 01 - basic Makefile Vagrantfile docs site test - vms . robot 02 - parsing README . md docker - compose . yml mkdocs . yml start - routers . sh testbed . yaml root @14 b56b5cc0ac : / home / devnet / cxta # You notice a directory 01-basic , which contains the first test script we want to examine and execute: Your First Test Case Change to the 01-basic directory and examine the 01-show1.robot file contained therein. It is a simple test suite which connects to the two routers we have spun up, collects a command which shows the version running on them, and compares them with an expected value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # cd 01 - basic # cat 01 - show1 . robot *** Settings *** Library CXTA Resource cxta . robot *** Variables *** # Location of the auto - generated testbed . yaml file which contains device # credentials . Rather than just using \" ../testbed.yaml \" , which assumes # the execution directory is the current directory , we set it # relative to the directory this . robot file is in ( ${ CURDIR } ) , which allows # us also to execute the test case from a different directory ( for example from # the parent directory using robot 01 - basic / ) ${ testbed } ${ CURDIR } / .. / testbed . yaml *** Test Cases *** Load testbed and connect to devices use testbed \" ${testbed} \" connect to device \" r1 \" connect to device \" r2 \" check version on r1 ${ output } = execute \" show version \" on device \" r1 \" Should Contain ${ output } Cisco IOS XE Software , Version 16 . 09 . 01 check version on r2 ${ output } = execute \" show version \" on device \" r2 \" Should Contain ${ output } Cisco IOS XE Software , Version 16 . 09 . 01 This file is a robotframework test file, and you notice different sections: the Settings section contains the libraries we want to load. For this lab, we are using the CXTA library and a set of libraries which are defined in the resource file cxta.robot . This file is bundled with the cxta libraries on the container, you can examine it via more /venv/lib/python3.6/site-packages/CXTA/robot/cxta.robot if you're interested. The Variables section allows you define variables which you can use in other sections of the file. Here we only define the ${testbed} variable which contains the location of the testbed.yaml file which contains the access information to the devices we'll be interacting with. The final Test Cases section contains the actual test cases we are executing when running this file. Robot (by default) executes each of the test cases in the order specified. A test case succeeds if all the steps within a test case succeed. Run the Test Case Let's run it, executing it via robot 01-show1.robot on the container: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 root @14 b56b5cc0ac : / home / devnet / cxta / 01 - basic # robot 01 - show1 . robot ============================================================================== 01 - Test1 ============================================================================== Load testbed and connect to devices | PASS | ------------------------------------------------------------------------------ check version on r1 | PASS | ------------------------------------------------------------------------------ check version on r2 | PASS | ------------------------------------------------------------------------------ 01 - Test1 | PASS | 3 critical tests , 3 passed , 0 failed 3 tests total , 3 passed , 0 failed ============================================================================== Output : / home / devnet / cxta / 01 - basic / output . xml Log : / home / devnet / cxta / 01 - basic / log . html Report : / home / devnet / cxta / 01 - basic / report . html root @14 b56b5cc0ac : / home / devnet / cxta / 01 - basic # Examine Robot Logfiles The console output from Robotframework is quite terse and doesn't provide much more information than pass/fail for each of the test cases executed. For more detailed reporting, as well as for troubleshooting in case things go wrong, you need to revert to additional files created by Robot (CXTA creates some more diagnostic files which we are not going to cover here): log.html is the most important log created and collects each test step including the device output and other diagnostic information report.html contains a high-level report which shows pass/fail of each test case output.xml contains essentially the same information as the former two files combined, however in structured XML format for automated post-processing Please open the log.html created in the directory XXXX/DEVWKS-1407/CLEUR2020-CXTA/01-basic folder on the laptop using a browser and click through the steps by expanding the test case steps (see below screenshot) Test Failures We suggest you repeat the test, but change the version value the ${output} is checked against in one of the \"check version on rX\" test cases, i.e. 1 2 3 4 [...] check version on r1 ${output} = execute \"show version\" on device \"r1\" Should Contain ${output} Cisco IOS XE Software, Version 99999999 re-run the test, and re-examine the log.html created to see how robot highlights the error(s). Test Suite Setup/Teardown By default, Robot executes all tests within a test suite (the robot file above in our example). If the number of tests grows large, there might be situations where you only want to run a subset of cases. Robotframework supports this by limiting the test case execution by tags (not used here) or by name. Let's try this using the -t (or --test ) command line argument. Let's now run a test only checking r1's version: 1 # robot - t \"check version on r1\" 01 - show1 . robot (you can also use wildcards, i.e. robot -t \"*r1\" 01-show1.robot would also work) You see the test failing: 1 2 3 4 5 6 7 8 9 ============================================================================== 01 - Test1 ============================================================================== check version on r1 | FAIL | AttributeError : 'NoneType' object has no attribute 'devices' ------------------------------------------------------------------------------ 01 - Test1 | FAIL | 1 critical test , 0 passed , 1 failed 1 test total , 0 passed , 1 failed The error message is unfortunately not that obvious, but if you examine the full .robot file, the first test case (\"Load testbed and connect to devices\") is now skipped, which causes subsequent test cases which rely on the device connections to fail. This highlights a problem with the chosen approach (which we introduced for educational purposes ;-) ) as test cases are dependent on each other, which is something we should avoid as much as possible. To support test interdependency, Robotframework (like many other testing frameworks) support Setup and Teardown functions which can be executed before a test case starts (and after a test case finishes). These setup functions can also be specified at a test suite level, i.e. before the first test starts and after the last test finishes. We prepared a test suite utilizing this functionality in file 01-show2.robot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 *** Settings *** Library CXTA Resource cxta . robot Suite Setup Load testbed and connect to devices *** Variables *** ${ testbed } ${ CURDIR } / .. / testbed . yaml *** Test Cases *** check version on r1 ${ output } = execute \" show version \" on device \" r1 \" Should Contain ${ output } Cisco IOS XE Software , Version 16 . 09 . 01 check version on r2 ${ output } = execute \" show version \" on device \" r2 \" Should Contain ${ output } Cisco IOS XE Software , Version 16 . 09 . 01 *** Keywords *** Load testbed and connect to devices use testbed \" ${testbed} \" connect to device \" r1 \" connect to device \" r2 \" Comparing this to 01-show1.robot, you'll notice that the first test case (where we connect to the devices) has now moved into the Keywords section, this creating a new Robot keyword \"Load testbed and connect to devices\", which is now called as part of the Suite Setup , i.e. before the first test is executed. With this change, we can now selectively run any test case: 1 2 3 4 5 6 7 8 9 10 11 # robot - t \"check version on r1\" 01 - show2 . robot ============================================================================== 01 - Test2 ============================================================================== check version on r1 | PASS | ------------------------------------------------------------------------------ 01 - Test2 | PASS | 1 critical test , 1 passed , 0 failed 1 test total , 1 passed , 0 failed [...] The console output only shows the test case executed, it doesn't show the Setup step, you need to revert to the log.html in the browser: What's next? Now that you have made yourself familiar with the environment and basic robot commands, let's move on to a more advanced use case which shows you the power of some of the CXTA and pyATS keywords.","title":"01 Basic Steps"},{"location":"01-basic/#basic-tests","text":"This Chapter introduces you to some basic Robotframework fundamentals and generic device interaction keywords.","title":"Basic Tests"},{"location":"01-basic/#test-execution-environment","text":"The Robotframework and CXTA runtime environment is installed on a pre-built Container, which has been started in the previous chapter . The directory structure containing the scripts and tests has been mounted into the container (into /home/devnet/cxta), so you can create/edit and examine files on the Linux operating system on the host (in XXXX/DEVWKS-1407/CLEUR2020-CXTA), while the execution happens on the container. Open an interactive session on the container using the following command: 1 docker exec - it cxta_devnet bash You will end up in the /home/devnet/cxta directory, and you can see all the files from the directory you started the environment from: 1 2 3 4 root @14 b56b5cc0ac : / home / devnet / cxta # ls 01 - basic Makefile Vagrantfile docs site test - vms . robot 02 - parsing README . md docker - compose . yml mkdocs . yml start - routers . sh testbed . yaml root @14 b56b5cc0ac : / home / devnet / cxta # You notice a directory 01-basic , which contains the first test script we want to examine and execute:","title":"Test Execution Environment"},{"location":"01-basic/#your-first-test-case","text":"Change to the 01-basic directory and examine the 01-show1.robot file contained therein. It is a simple test suite which connects to the two routers we have spun up, collects a command which shows the version running on them, and compares them with an expected value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # cd 01 - basic # cat 01 - show1 . robot *** Settings *** Library CXTA Resource cxta . robot *** Variables *** # Location of the auto - generated testbed . yaml file which contains device # credentials . Rather than just using \" ../testbed.yaml \" , which assumes # the execution directory is the current directory , we set it # relative to the directory this . robot file is in ( ${ CURDIR } ) , which allows # us also to execute the test case from a different directory ( for example from # the parent directory using robot 01 - basic / ) ${ testbed } ${ CURDIR } / .. / testbed . yaml *** Test Cases *** Load testbed and connect to devices use testbed \" ${testbed} \" connect to device \" r1 \" connect to device \" r2 \" check version on r1 ${ output } = execute \" show version \" on device \" r1 \" Should Contain ${ output } Cisco IOS XE Software , Version 16 . 09 . 01 check version on r2 ${ output } = execute \" show version \" on device \" r2 \" Should Contain ${ output } Cisco IOS XE Software , Version 16 . 09 . 01 This file is a robotframework test file, and you notice different sections: the Settings section contains the libraries we want to load. For this lab, we are using the CXTA library and a set of libraries which are defined in the resource file cxta.robot . This file is bundled with the cxta libraries on the container, you can examine it via more /venv/lib/python3.6/site-packages/CXTA/robot/cxta.robot if you're interested. The Variables section allows you define variables which you can use in other sections of the file. Here we only define the ${testbed} variable which contains the location of the testbed.yaml file which contains the access information to the devices we'll be interacting with. The final Test Cases section contains the actual test cases we are executing when running this file. Robot (by default) executes each of the test cases in the order specified. A test case succeeds if all the steps within a test case succeed.","title":"Your First Test Case"},{"location":"01-basic/#run-the-test-case","text":"Let's run it, executing it via robot 01-show1.robot on the container: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 root @14 b56b5cc0ac : / home / devnet / cxta / 01 - basic # robot 01 - show1 . robot ============================================================================== 01 - Test1 ============================================================================== Load testbed and connect to devices | PASS | ------------------------------------------------------------------------------ check version on r1 | PASS | ------------------------------------------------------------------------------ check version on r2 | PASS | ------------------------------------------------------------------------------ 01 - Test1 | PASS | 3 critical tests , 3 passed , 0 failed 3 tests total , 3 passed , 0 failed ============================================================================== Output : / home / devnet / cxta / 01 - basic / output . xml Log : / home / devnet / cxta / 01 - basic / log . html Report : / home / devnet / cxta / 01 - basic / report . html root @14 b56b5cc0ac : / home / devnet / cxta / 01 - basic #","title":"Run the Test Case"},{"location":"01-basic/#examine-robot-logfiles","text":"The console output from Robotframework is quite terse and doesn't provide much more information than pass/fail for each of the test cases executed. For more detailed reporting, as well as for troubleshooting in case things go wrong, you need to revert to additional files created by Robot (CXTA creates some more diagnostic files which we are not going to cover here): log.html is the most important log created and collects each test step including the device output and other diagnostic information report.html contains a high-level report which shows pass/fail of each test case output.xml contains essentially the same information as the former two files combined, however in structured XML format for automated post-processing Please open the log.html created in the directory XXXX/DEVWKS-1407/CLEUR2020-CXTA/01-basic folder on the laptop using a browser and click through the steps by expanding the test case steps (see below screenshot)","title":"Examine Robot Logfiles"},{"location":"01-basic/#test-failures","text":"We suggest you repeat the test, but change the version value the ${output} is checked against in one of the \"check version on rX\" test cases, i.e. 1 2 3 4 [...] check version on r1 ${output} = execute \"show version\" on device \"r1\" Should Contain ${output} Cisco IOS XE Software, Version 99999999 re-run the test, and re-examine the log.html created to see how robot highlights the error(s).","title":"Test Failures"},{"location":"01-basic/#test-suite-setupteardown","text":"By default, Robot executes all tests within a test suite (the robot file above in our example). If the number of tests grows large, there might be situations where you only want to run a subset of cases. Robotframework supports this by limiting the test case execution by tags (not used here) or by name. Let's try this using the -t (or --test ) command line argument. Let's now run a test only checking r1's version: 1 # robot - t \"check version on r1\" 01 - show1 . robot (you can also use wildcards, i.e. robot -t \"*r1\" 01-show1.robot would also work) You see the test failing: 1 2 3 4 5 6 7 8 9 ============================================================================== 01 - Test1 ============================================================================== check version on r1 | FAIL | AttributeError : 'NoneType' object has no attribute 'devices' ------------------------------------------------------------------------------ 01 - Test1 | FAIL | 1 critical test , 0 passed , 1 failed 1 test total , 0 passed , 1 failed The error message is unfortunately not that obvious, but if you examine the full .robot file, the first test case (\"Load testbed and connect to devices\") is now skipped, which causes subsequent test cases which rely on the device connections to fail. This highlights a problem with the chosen approach (which we introduced for educational purposes ;-) ) as test cases are dependent on each other, which is something we should avoid as much as possible. To support test interdependency, Robotframework (like many other testing frameworks) support Setup and Teardown functions which can be executed before a test case starts (and after a test case finishes). These setup functions can also be specified at a test suite level, i.e. before the first test starts and after the last test finishes. We prepared a test suite utilizing this functionality in file 01-show2.robot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 *** Settings *** Library CXTA Resource cxta . robot Suite Setup Load testbed and connect to devices *** Variables *** ${ testbed } ${ CURDIR } / .. / testbed . yaml *** Test Cases *** check version on r1 ${ output } = execute \" show version \" on device \" r1 \" Should Contain ${ output } Cisco IOS XE Software , Version 16 . 09 . 01 check version on r2 ${ output } = execute \" show version \" on device \" r2 \" Should Contain ${ output } Cisco IOS XE Software , Version 16 . 09 . 01 *** Keywords *** Load testbed and connect to devices use testbed \" ${testbed} \" connect to device \" r1 \" connect to device \" r2 \" Comparing this to 01-show1.robot, you'll notice that the first test case (where we connect to the devices) has now moved into the Keywords section, this creating a new Robot keyword \"Load testbed and connect to devices\", which is now called as part of the Suite Setup , i.e. before the first test is executed. With this change, we can now selectively run any test case: 1 2 3 4 5 6 7 8 9 10 11 # robot - t \"check version on r1\" 01 - show2 . robot ============================================================================== 01 - Test2 ============================================================================== check version on r1 | PASS | ------------------------------------------------------------------------------ 01 - Test2 | PASS | 1 critical test , 1 passed , 0 failed 1 test total , 1 passed , 0 failed [...] The console output only shows the test case executed, it doesn't show the Setup step, you need to revert to the log.html in the browser:","title":"Test Suite Setup/Teardown"},{"location":"01-basic/#whats-next","text":"Now that you have made yourself familiar with the environment and basic robot commands, let's move on to a more advanced use case which shows you the power of some of the CXTA and pyATS keywords.","title":"What's next?"},{"location":"02-parsing/","text":"Command Output Parsing Exercises Despite the enhancements to deal with network devices in a programmatic way over APIs (i.e. REST, NETCONF, etc.), parsing command line output remains to be a major task when dealing with heterogeneous network environments. CXTA provides a variety of keywords and approaches to deal with parsing, which we want to introduce in this exercise. We again leverage the device environment shown earlier, and demonstrate multiple approaches on how to parse text data. Simple Parsing In this test suite we show how to use simple approaches like checking for texts appearing, or extracting values from tests using Regular Expressions, a common way to parse text output. The command output we'll parse is the same for all the test cases in the first suite: show ip ospf neighbor which displays the OSPF neighbour status on one of the two routers (r1 in this case): 1 2 3 4 r1 # show ip ospf neighbor Neighbor ID Pri State Dead Time Address Interface 10 . 0 . 0 . 2 1 FULL / DR 00 : 00 : 31 172 . 16 . 0 . 2 GigabitEthernet2 you can connect to the device (using vagrant ssh r1 from outside the container) to check yourself. Please change to the 02-parsing directory ( cd ../02-parsing , assuming you are still in the 01-basic directory from the previous test) and examine the file 02-simple.robot (also shown below). A few notes here: CXTA has evolved over time and has aggregated keywords from different sources within Cisco and externally over the years, and so some redundancy has been accumulated where the same task can be achieved using different keywords. For example the run \"show ip ospf neighbor\" keyword on a device which has previously been selected is pretty much equivalent with the execute command .. keyword seen in the previous chapter. As robot interprets the backslash ( \\ ), we need to escape the backslashes used in Regular expressions (hence the \\\\ seen in the expressions below) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 # cd .. / 02 - parsing / # cat 02 - simple . robot *** Settings *** Library CXTA Resource cxta . robot Library Collections # Imports a public Robot framework library which provides the keyword \" Log List \" used in one of the tests Suite Setup Load testbed and connect to devices *** Variables *** ${ testbed } ${ CURDIR } / .. / testbed . yaml ${ device } r1 # Device under test ${ nbr_id } 10 . 0 . 0 . 2 # excpected neighbour router id *** Test Cases *** Check OSPF neighbour state - basic output match # using CXTA keywords which are a bit shorter than the ones we ' ve seen select device \" ${device} \" run \" show ip ospf neighbor \" output contains \" FULL \" Check OSPF neighbour ID using regexp parsing select device \" ${device} \" run \" show ip ospf neighbor \" # uses a cxta keyword to find all regex pattern matches on the output from the show command above # the pattern will match IPv4 address , e . g . 192 . 168 . 10 . All pattern matches will be saved in a list . # regex backslashes need to be escaped as Robot interprets them as well ${ output } = extract patterns \" \\\\ d+\\. \\\\ d+\\. \\\\ d+\\. \\\\ d+ \" # uses a couple of keywords to log the result of the ' extract patterns ' keyword - view these in the log . html log ${ output } log list ${ output } # check if the first element of the list is what we expect Should be Equal as Strings ${ output }[ 0 ] ${ nbr_id } Check OSPF neighbour state using regexp parsing - 1 # if the whole test suite was executed , these keywords would not be needed as the output # would still be in the buffer from the previous test case select device \" ${device} \" run \" show ip ospf neighbor \" # uses a longer regex pattern to retrieve the ospf state , here using anchoring to fetch # only the state , ( [\\\\ w ] + ) ${ output } = extract pattern \" \\\\ d+\\. \\\\ d+\\. \\\\ d+\\. \\\\ d+ \\\\ s+ \\\\ d+ \\\\ s+([ \\\\ w]+) \" Should be equal ${ output } FULL Check OSPF neighbour state using regexp parsing - 2 select device \" ${device} \" run \" show ip ospf neighbor \" # instead of extracting patterns , we can verify that the output matches a pattern # in this example we are checking that ' FULL/ ' is the state output matches pattern \" \\\\ d+\\. \\\\ d+\\. \\\\ d+\\. \\\\ d+ \\\\ s+ \\\\ d+ \\\\ s+FULL\\/.* \" output matches pattern \" .*FULL\\/.* \" *** Keywords *** Load testbed and connect to devices use testbed \" ${testbed} \" connect to device \" ${device} \" Run this test (from within the container) and examine the log.html created. 1 root @14 b56b5cc0ac : / home / devnet / cxta / 02 - parsing # robot 02 - simple . robot Bonus Exercise: Leveraging Parameterization You might have noticed that we have parameterized the router name and expected router ID in the above test cases using variables. This enables us to easily adapt the test to a different environment: We can easily re-run the test on the other router (r2) and this check for a different neighbor IP address (10.0.0.1) by overwriting the defined variables values on the command line using the -v VAR:VALUE command line options. Please give it a go: 1 # robot - v device : r2 - v nbr_id : 10 . 0 . 0 . 1 02 - simple . robot More Complex Parsing Parsing text using regular expression can be cumbersome, especially if the use case requires parsing multiple values from a single command output, potentially spread across different line. CXTA offers two approaches: TextFSM (shown below), and pyATS Genie (next chapter) Parsing using TextFSM TextFSM is a Python module that implements a template based state machine for parsing semi-formatted text. Originally developed to allow programmatic access to information given by the output of CLI driven devices, such as network routers and switches, it can however be used for any such textual output. CXTA has close to 1000 TextFSM templates which are able to parse a large variety of command from Cisco and 3rd party network devices, and the test user can also supply his/her own. In one of the tests defined in 02-complex.robot , we use a custom TextFSM file just for demo purposes, you can find it as show_ip_ospf_neighbor.textfsm in the current directory: 1 2 3 4 5 6 7 8 9 Value NEIGHBOR_ID (\\d+.\\d+.\\d+.\\d+) Value PRIORITY (\\d+) Value STATE (\\S+\\/\\s+\\-|\\S+) Value DEAD_TIME (\\d+:\\d+:\\d+) Value ADDRESS (\\d+.\\d+.\\d+.\\d+) Value INTERFACE (\\S+) Start ^ ${ NEIGHBOR_ID } \\s+ ${ PRIORITY } \\s+ ${ STATE } \\s+ ${ DEAD_TIME } \\s+ ${ ADDRESS } \\s+ ${ INTERFACE } -> Record This template extracts values (as defined on the top of the file) for each of the lines which appear in the command output of \"show ip ospf neighbor\" (shared earlier), and records them in a dictionary/JSON object. Please check the test case below, which runs and parses the \"show ip ospf neighbor\" output using above TextFSM template, and subsequently extracts the information based on the field names defined in the TextFSM template (i.e. NEIGHBOR_ID and NBR_STATE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Check OSPF neighbour ID using TextFSM select device \" r1 \" # runs a command and parses it through the TextFSM template provided # cxta includes a large collection of templates ( view the ' Command Map ' page in the documentation ) # though you are able to specify your own template , as we do in this example run parsed \" show ip ospf neighbor \" with template \" ${CURDIR}/show_ip_ospf_neighbor.textfsm \" # get the data from the value of ' NEIGHBOR_ID ' from the dictionary that was created in the keyword above ${ NBR_ID } = get parsed \" NEIGHBOR_ID \" # the checks below assume that we only see a single neighbor . If multiple neighbors # are found , ${ NBR_ID } will be a list , and we would need to iterate through the list , we # leave this as an exercise for the reader ;-) Should be Equal as Strings ${ NBR_ID } 10 . 0 . 0 . 2 # another example , this time getting the neighbor state ${ NBR_STATE } = get parsed \" STATE \" Should Contain ${ NBR_STATE } FULL Instead of using the get parsed keywords, you could also collect the return value from the run parsed ... keyword and examine the dictionary directly. We'll get back to parsing dict/json later. Configuring and Retrying The next test case also use TextFSM parsing, this time using one of CXTA's TextFSM templates (show cdp neighbor, you can view the template at /venv/lib/python3.6/site-packages/CXTA/core/commands/ios/show_cdp_neighbors.textfsm on the container). But to add a bit more \"fun\", we first configure CDP (Cisco Discovery Protocol, a simple protocol which allows you to discover [network] devices connected to a router), then re-run the command until a neighbour is seen (this can take up to a minute as CDP packets are not sent that frequently), before we parse it and check the host name of the neighbouring node. Finally we remove the CDP configuration to restore the test bed to its previous state (which is always a good practice): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 *** Variables *** ${ CDP_CONFIG } = cdp run \\ ninterface GigabitEthernet2 \\ ncdp enable ${ REMOVE_CDP_CONFIG } no cdp run \\ ninterface GigabitEthernet2 \\ nno cdp enable [...] Enable CDP and check hostname of neighbor ( r2 ) [ Setup ] configure \" ${CDP_CONFIG} \" on devices \" r1;r2 \" select device \" r1 \" # It takes a bit for the CDP neighbor to show , so we repeat a keyword for a bit we see the relevant # info in the output set monitor interval to \" 15 \" seconds monitor command \" show cdp neighbors \" until output contains \" Total cdp entries displayed : 1 \" or \" 60 \" seconds # now we have a cdp neighbor , we will run the neighbor table through the TextFSM parser ${ output } = run parsed \" show cdp neighbors \" log ${ output } # using the local interface , we can get the device id ( hostname ) of the neighbor ${ HOSTNAME } = get parsed \" device_id \" where \" local_intf \" is \" Gig 2 \" log ${ HOSTNAME } Should contain ${ HOSTNAME } r2 [ Teardown ] configure \" ${REMOVE_CDP_CONFIG} \" on devices \" r1;r2 \" A few things to note here: You see that we put the configuration and the removal of CDP into test case Setup and Teardown functions (lines 8 and 22). You have already seen the Suite Setup which allows us to initialize the environment prior to the first test case executed, and the Test Setup function is equivalent within the test case context, i.e. we perform an initialization before the the first test keyword runs. Removing the configuration in the Teardown is especially important. This ensures that the configuration is removed, no matter if any prior test step failed or not. We use the CXTA keyword monitor command ... to check the presence of a specific string. We could have also used a built-in Robot keyword Repeat Keyword to repeat the execution (left as a bonus exercise). Finally, we use a different get parsed ... keyword (#19) which again extracts values from the parsed output, but this time using an additional condition (especially practical if there was more than one neighbour). Next Steps If you still have time, we would like to share a different, and even more powerful and versatile approach on how to parse Cisco and some other devices: Parsing with pyATS GENIE","title":"02 Parsing Text"},{"location":"02-parsing/#command-output-parsing-exercises","text":"Despite the enhancements to deal with network devices in a programmatic way over APIs (i.e. REST, NETCONF, etc.), parsing command line output remains to be a major task when dealing with heterogeneous network environments. CXTA provides a variety of keywords and approaches to deal with parsing, which we want to introduce in this exercise. We again leverage the device environment shown earlier, and demonstrate multiple approaches on how to parse text data.","title":"Command Output Parsing Exercises"},{"location":"02-parsing/#simple-parsing","text":"In this test suite we show how to use simple approaches like checking for texts appearing, or extracting values from tests using Regular Expressions, a common way to parse text output. The command output we'll parse is the same for all the test cases in the first suite: show ip ospf neighbor which displays the OSPF neighbour status on one of the two routers (r1 in this case): 1 2 3 4 r1 # show ip ospf neighbor Neighbor ID Pri State Dead Time Address Interface 10 . 0 . 0 . 2 1 FULL / DR 00 : 00 : 31 172 . 16 . 0 . 2 GigabitEthernet2 you can connect to the device (using vagrant ssh r1 from outside the container) to check yourself. Please change to the 02-parsing directory ( cd ../02-parsing , assuming you are still in the 01-basic directory from the previous test) and examine the file 02-simple.robot (also shown below). A few notes here: CXTA has evolved over time and has aggregated keywords from different sources within Cisco and externally over the years, and so some redundancy has been accumulated where the same task can be achieved using different keywords. For example the run \"show ip ospf neighbor\" keyword on a device which has previously been selected is pretty much equivalent with the execute command .. keyword seen in the previous chapter. As robot interprets the backslash ( \\ ), we need to escape the backslashes used in Regular expressions (hence the \\\\ seen in the expressions below) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 # cd .. / 02 - parsing / # cat 02 - simple . robot *** Settings *** Library CXTA Resource cxta . robot Library Collections # Imports a public Robot framework library which provides the keyword \" Log List \" used in one of the tests Suite Setup Load testbed and connect to devices *** Variables *** ${ testbed } ${ CURDIR } / .. / testbed . yaml ${ device } r1 # Device under test ${ nbr_id } 10 . 0 . 0 . 2 # excpected neighbour router id *** Test Cases *** Check OSPF neighbour state - basic output match # using CXTA keywords which are a bit shorter than the ones we ' ve seen select device \" ${device} \" run \" show ip ospf neighbor \" output contains \" FULL \" Check OSPF neighbour ID using regexp parsing select device \" ${device} \" run \" show ip ospf neighbor \" # uses a cxta keyword to find all regex pattern matches on the output from the show command above # the pattern will match IPv4 address , e . g . 192 . 168 . 10 . All pattern matches will be saved in a list . # regex backslashes need to be escaped as Robot interprets them as well ${ output } = extract patterns \" \\\\ d+\\. \\\\ d+\\. \\\\ d+\\. \\\\ d+ \" # uses a couple of keywords to log the result of the ' extract patterns ' keyword - view these in the log . html log ${ output } log list ${ output } # check if the first element of the list is what we expect Should be Equal as Strings ${ output }[ 0 ] ${ nbr_id } Check OSPF neighbour state using regexp parsing - 1 # if the whole test suite was executed , these keywords would not be needed as the output # would still be in the buffer from the previous test case select device \" ${device} \" run \" show ip ospf neighbor \" # uses a longer regex pattern to retrieve the ospf state , here using anchoring to fetch # only the state , ( [\\\\ w ] + ) ${ output } = extract pattern \" \\\\ d+\\. \\\\ d+\\. \\\\ d+\\. \\\\ d+ \\\\ s+ \\\\ d+ \\\\ s+([ \\\\ w]+) \" Should be equal ${ output } FULL Check OSPF neighbour state using regexp parsing - 2 select device \" ${device} \" run \" show ip ospf neighbor \" # instead of extracting patterns , we can verify that the output matches a pattern # in this example we are checking that ' FULL/ ' is the state output matches pattern \" \\\\ d+\\. \\\\ d+\\. \\\\ d+\\. \\\\ d+ \\\\ s+ \\\\ d+ \\\\ s+FULL\\/.* \" output matches pattern \" .*FULL\\/.* \" *** Keywords *** Load testbed and connect to devices use testbed \" ${testbed} \" connect to device \" ${device} \" Run this test (from within the container) and examine the log.html created. 1 root @14 b56b5cc0ac : / home / devnet / cxta / 02 - parsing # robot 02 - simple . robot","title":"Simple Parsing"},{"location":"02-parsing/#bonus-exercise-leveraging-parameterization","text":"You might have noticed that we have parameterized the router name and expected router ID in the above test cases using variables. This enables us to easily adapt the test to a different environment: We can easily re-run the test on the other router (r2) and this check for a different neighbor IP address (10.0.0.1) by overwriting the defined variables values on the command line using the -v VAR:VALUE command line options. Please give it a go: 1 # robot - v device : r2 - v nbr_id : 10 . 0 . 0 . 1 02 - simple . robot","title":"Bonus Exercise: Leveraging Parameterization"},{"location":"02-parsing/#more-complex-parsing","text":"Parsing text using regular expression can be cumbersome, especially if the use case requires parsing multiple values from a single command output, potentially spread across different line. CXTA offers two approaches: TextFSM (shown below), and pyATS Genie (next chapter)","title":"More Complex Parsing"},{"location":"02-parsing/#parsing-using-textfsm","text":"TextFSM is a Python module that implements a template based state machine for parsing semi-formatted text. Originally developed to allow programmatic access to information given by the output of CLI driven devices, such as network routers and switches, it can however be used for any such textual output. CXTA has close to 1000 TextFSM templates which are able to parse a large variety of command from Cisco and 3rd party network devices, and the test user can also supply his/her own. In one of the tests defined in 02-complex.robot , we use a custom TextFSM file just for demo purposes, you can find it as show_ip_ospf_neighbor.textfsm in the current directory: 1 2 3 4 5 6 7 8 9 Value NEIGHBOR_ID (\\d+.\\d+.\\d+.\\d+) Value PRIORITY (\\d+) Value STATE (\\S+\\/\\s+\\-|\\S+) Value DEAD_TIME (\\d+:\\d+:\\d+) Value ADDRESS (\\d+.\\d+.\\d+.\\d+) Value INTERFACE (\\S+) Start ^ ${ NEIGHBOR_ID } \\s+ ${ PRIORITY } \\s+ ${ STATE } \\s+ ${ DEAD_TIME } \\s+ ${ ADDRESS } \\s+ ${ INTERFACE } -> Record This template extracts values (as defined on the top of the file) for each of the lines which appear in the command output of \"show ip ospf neighbor\" (shared earlier), and records them in a dictionary/JSON object. Please check the test case below, which runs and parses the \"show ip ospf neighbor\" output using above TextFSM template, and subsequently extracts the information based on the field names defined in the TextFSM template (i.e. NEIGHBOR_ID and NBR_STATE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Check OSPF neighbour ID using TextFSM select device \" r1 \" # runs a command and parses it through the TextFSM template provided # cxta includes a large collection of templates ( view the ' Command Map ' page in the documentation ) # though you are able to specify your own template , as we do in this example run parsed \" show ip ospf neighbor \" with template \" ${CURDIR}/show_ip_ospf_neighbor.textfsm \" # get the data from the value of ' NEIGHBOR_ID ' from the dictionary that was created in the keyword above ${ NBR_ID } = get parsed \" NEIGHBOR_ID \" # the checks below assume that we only see a single neighbor . If multiple neighbors # are found , ${ NBR_ID } will be a list , and we would need to iterate through the list , we # leave this as an exercise for the reader ;-) Should be Equal as Strings ${ NBR_ID } 10 . 0 . 0 . 2 # another example , this time getting the neighbor state ${ NBR_STATE } = get parsed \" STATE \" Should Contain ${ NBR_STATE } FULL Instead of using the get parsed keywords, you could also collect the return value from the run parsed ... keyword and examine the dictionary directly. We'll get back to parsing dict/json later.","title":"Parsing using TextFSM"},{"location":"02-parsing/#configuring-and-retrying","text":"The next test case also use TextFSM parsing, this time using one of CXTA's TextFSM templates (show cdp neighbor, you can view the template at /venv/lib/python3.6/site-packages/CXTA/core/commands/ios/show_cdp_neighbors.textfsm on the container). But to add a bit more \"fun\", we first configure CDP (Cisco Discovery Protocol, a simple protocol which allows you to discover [network] devices connected to a router), then re-run the command until a neighbour is seen (this can take up to a minute as CDP packets are not sent that frequently), before we parse it and check the host name of the neighbouring node. Finally we remove the CDP configuration to restore the test bed to its previous state (which is always a good practice): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 *** Variables *** ${ CDP_CONFIG } = cdp run \\ ninterface GigabitEthernet2 \\ ncdp enable ${ REMOVE_CDP_CONFIG } no cdp run \\ ninterface GigabitEthernet2 \\ nno cdp enable [...] Enable CDP and check hostname of neighbor ( r2 ) [ Setup ] configure \" ${CDP_CONFIG} \" on devices \" r1;r2 \" select device \" r1 \" # It takes a bit for the CDP neighbor to show , so we repeat a keyword for a bit we see the relevant # info in the output set monitor interval to \" 15 \" seconds monitor command \" show cdp neighbors \" until output contains \" Total cdp entries displayed : 1 \" or \" 60 \" seconds # now we have a cdp neighbor , we will run the neighbor table through the TextFSM parser ${ output } = run parsed \" show cdp neighbors \" log ${ output } # using the local interface , we can get the device id ( hostname ) of the neighbor ${ HOSTNAME } = get parsed \" device_id \" where \" local_intf \" is \" Gig 2 \" log ${ HOSTNAME } Should contain ${ HOSTNAME } r2 [ Teardown ] configure \" ${REMOVE_CDP_CONFIG} \" on devices \" r1;r2 \" A few things to note here: You see that we put the configuration and the removal of CDP into test case Setup and Teardown functions (lines 8 and 22). You have already seen the Suite Setup which allows us to initialize the environment prior to the first test case executed, and the Test Setup function is equivalent within the test case context, i.e. we perform an initialization before the the first test keyword runs. Removing the configuration in the Teardown is especially important. This ensures that the configuration is removed, no matter if any prior test step failed or not. We use the CXTA keyword monitor command ... to check the presence of a specific string. We could have also used a built-in Robot keyword Repeat Keyword to repeat the execution (left as a bonus exercise). Finally, we use a different get parsed ... keyword (#19) which again extracts values from the parsed output, but this time using an additional condition (especially practical if there was more than one neighbour).","title":"Configuring and Retrying"},{"location":"02-parsing/#next-steps","text":"If you still have time, we would like to share a different, and even more powerful and versatile approach on how to parse Cisco and some other devices: Parsing with pyATS GENIE","title":"Next Steps"},{"location":"03-genie/","text":"Parsing with pyATS Genie CXTA leverages Cisco's pyATS framework for most of its device-related keywords, a testing framework used by Cisco's core product development organization. pyATS is available on DevNet and is free to use. The libraries available also include Robotframework keywords, some of which we've already used (like connect to device or use testbed ), and in this exercise we want to demonstrate Genie , which deserves its own chapter. Please change to the 03-genie directory and examine the 03-genie.robot test suite, which contains two test cases which we explain separately: 1 2 cd .. / 03 - genie cat 03 - genie . robot Parsing a Specific Command First we want to perform a similar task as shown before: Parsing the OSPF neighbor information. This is what the first test case in the 03-parsing-genie.robot file does: 1 2 3 4 5 6 7 8 9 10 Get the ospf neighbor ID from R1 using Genie keywords ( pyats ) # runs a command through the genie parser , it returns a dictionary & { result } = parse \" show ip ospf neighbor detail \" on device \" r1 \" Log Dict ${ result } ${ nbr_id } = Get Value From Json ${ result } $.. neighbors . * . neighbor_router_id Should be Equal as Strings ${ nbr_id }[ 0 ] 10 . 0 . 0 . 2 ${ nbr_state } = Get Value From Json ${ result } $.. neighbors . * . state Should be Equal as Strings ${ nbr_state }[ 0 ] full Please run the test (either run the whole file, or just run this one using robot -t \"Get the ospf*\" 03-genie.robot ) and open the resulting log.html in your browser. Please first expand on the parse \"show ip ospf neighbor detail\" on device \"r1\" keyword. You'll notice that the Genie library uses multiple commands on the device to collect the required information. The inner workings of how this is achieved is fully transparent, a big time saver when dealing with (network) devices: As in the TextFSM examples earlier, the result is returned as a dictionary, and line 4 dumps the contents into log.html: The data is structured according to Genie datamodels, which are common across device types and OS (IOS-XE, IOS-XR, etc.). Lines 6 and 9 now extract specific values from this dictionary and compare it with their expected values. TODO: Ava to elaborate on the filter constructs in #6 and #9 Learning a Feature Genie also offers a very powerful mechanism to gather all sorts of information about a specific feature configured and running on a device. Let's use this approach now to verify the hello interval present on the routers, checking each of the two routers individually. Please examine the 2nd test case in 03-genie.robot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Check the OSPF hello interval on a specific interface # we now use a keyword specified in the keyword section of this robot file below # in the keyword the user can specify the device name and the interface , so the # very same check can be reused Check if OSPF hello interval on device \" r1 \" interface \" GigabitEthernet2 \" is \" 10 \" Check if OSPF hello interval on device \" r2 \" interface \" GigabitEthernet2 \" is \" 10 \" *** Keywords *** Check if OSPF hello interval on device \" ${device} \" interface \" ${interface} \" is \" ${interval} \" # uses a pyats keyword to learn operational information on ospf # the keyword runs various ospf commands as per the platforms model in genie ${ d } = learn \" ospf \" on device \" ${device} \" # the learn keyword returns a python object , convert this into a dict ${ result } = Set Variable ${ d . to_dict () } Log Dict ${ result } ${ v } = Get Value From Json ${ result } $.. interfaces .${ interface }. hello_interval Should be equal as numbers ${ v [ 0 ]} ${ interval } Instead of repeating things twice for r1 and r2, we introduce a keyword (line 9) with parameters, and call this keyword for each router (5+6). Within the keyword, we call the learn \"ospf\" on device \"${device}\" keyword, convert the result to a dictionary, and again use a Json filter construct to retrieve the value we're interested in. Please note the use of the parameters defined in the keyword (${device}, ${interface} and ${interval}). Please run the test case ( robot 03-genie.robot ), examine the log.html and take a special look at the Log Dict output which contains the full information returned by learn \"ospf\".. (also here ). We hope you'll be amazed by the wealth of information available at your fingertips. Conclusion We hope you have enjoyed these exercises. Please visit us to discuss how Cisco CX can help you in your test automation journey!","title":"03 pyATS Genie"},{"location":"03-genie/#parsing-with-pyats-genie","text":"CXTA leverages Cisco's pyATS framework for most of its device-related keywords, a testing framework used by Cisco's core product development organization. pyATS is available on DevNet and is free to use. The libraries available also include Robotframework keywords, some of which we've already used (like connect to device or use testbed ), and in this exercise we want to demonstrate Genie , which deserves its own chapter. Please change to the 03-genie directory and examine the 03-genie.robot test suite, which contains two test cases which we explain separately: 1 2 cd .. / 03 - genie cat 03 - genie . robot","title":"Parsing with pyATS Genie"},{"location":"03-genie/#parsing-a-specific-command","text":"First we want to perform a similar task as shown before: Parsing the OSPF neighbor information. This is what the first test case in the 03-parsing-genie.robot file does: 1 2 3 4 5 6 7 8 9 10 Get the ospf neighbor ID from R1 using Genie keywords ( pyats ) # runs a command through the genie parser , it returns a dictionary & { result } = parse \" show ip ospf neighbor detail \" on device \" r1 \" Log Dict ${ result } ${ nbr_id } = Get Value From Json ${ result } $.. neighbors . * . neighbor_router_id Should be Equal as Strings ${ nbr_id }[ 0 ] 10 . 0 . 0 . 2 ${ nbr_state } = Get Value From Json ${ result } $.. neighbors . * . state Should be Equal as Strings ${ nbr_state }[ 0 ] full Please run the test (either run the whole file, or just run this one using robot -t \"Get the ospf*\" 03-genie.robot ) and open the resulting log.html in your browser. Please first expand on the parse \"show ip ospf neighbor detail\" on device \"r1\" keyword. You'll notice that the Genie library uses multiple commands on the device to collect the required information. The inner workings of how this is achieved is fully transparent, a big time saver when dealing with (network) devices: As in the TextFSM examples earlier, the result is returned as a dictionary, and line 4 dumps the contents into log.html: The data is structured according to Genie datamodels, which are common across device types and OS (IOS-XE, IOS-XR, etc.). Lines 6 and 9 now extract specific values from this dictionary and compare it with their expected values. TODO: Ava to elaborate on the filter constructs in #6 and #9","title":"Parsing a Specific Command"},{"location":"03-genie/#learning-a-feature","text":"Genie also offers a very powerful mechanism to gather all sorts of information about a specific feature configured and running on a device. Let's use this approach now to verify the hello interval present on the routers, checking each of the two routers individually. Please examine the 2nd test case in 03-genie.robot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Check the OSPF hello interval on a specific interface # we now use a keyword specified in the keyword section of this robot file below # in the keyword the user can specify the device name and the interface , so the # very same check can be reused Check if OSPF hello interval on device \" r1 \" interface \" GigabitEthernet2 \" is \" 10 \" Check if OSPF hello interval on device \" r2 \" interface \" GigabitEthernet2 \" is \" 10 \" *** Keywords *** Check if OSPF hello interval on device \" ${device} \" interface \" ${interface} \" is \" ${interval} \" # uses a pyats keyword to learn operational information on ospf # the keyword runs various ospf commands as per the platforms model in genie ${ d } = learn \" ospf \" on device \" ${device} \" # the learn keyword returns a python object , convert this into a dict ${ result } = Set Variable ${ d . to_dict () } Log Dict ${ result } ${ v } = Get Value From Json ${ result } $.. interfaces .${ interface }. hello_interval Should be equal as numbers ${ v [ 0 ]} ${ interval } Instead of repeating things twice for r1 and r2, we introduce a keyword (line 9) with parameters, and call this keyword for each router (5+6). Within the keyword, we call the learn \"ospf\" on device \"${device}\" keyword, convert the result to a dictionary, and again use a Json filter construct to retrieve the value we're interested in. Please note the use of the parameters defined in the keyword (${device}, ${interface} and ${interval}). Please run the test case ( robot 03-genie.robot ), examine the log.html and take a special look at the Log Dict output which contains the full information returned by learn \"ospf\".. (also here ). We hope you'll be amazed by the wealth of information available at your fingertips.","title":"Learning a Feature"},{"location":"03-genie/#conclusion","text":"We hope you have enjoyed these exercises. Please visit us to discuss how Cisco CX can help you in your test automation journey!","title":"Conclusion"}]}