{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to CLEUR 2020 DEVWKS-1407 Please use the navigation on the left to move between exercises, starting with 00-Setup.","title":"Overview"},{"location":"#welcome-to-cleur-2020-devwks-1407","text":"Please use the navigation on the left to move between exercises, starting with 00-Setup.","title":"Welcome to CLEUR 2020 DEVWKS-1407"},{"location":"00-setup/","text":"Bringing up the Topology Overview We have created a setup on this laptop you are sitting in front of which consists of a CXTA docker container containing the Python runtime environment to execute the tests two virtual IOS-XE devices which serve as units-under-test (UUT) The setup is depicted in the below diagram. Start the Environment To start the environment, please execute the following commands from your Linux shell: cd xxx/DEVWKS-1407 ./start-routers.sh This shell script performs the following tasks: It uses Vagrant to bring up the two IOS-XE virtual routers (using Virtualbox) Performs an initial configuration of the devices (essentially setting the hostname and configures IPv4/IPv6 on the link between the devices) Creates a testbed.yaml file which contains the device credentials and SSH ports to connect to the two virtual devices Starts the CXTA container (using docker-compose) As a final step, a Robot/CXTA test is run which verifies the basic connectivity. If all went well, the script output should end with below: ============================================================================== Test-Vms ============================================================================== connect to all devices | PASS | Connected to ['r1', 'r2'] ------------------------------------------------------------------------------ Test-Vms | PASS | 1 critical test, 1 passed, 0 failed 1 test total, 1 passed, 0 failed ============================================================================== If the test shows an error, it typically points to an issue bringing up the VM. Please refer to the next paragraph for some troubleshooting guidance. Please check for a full output of a working startup at the end of this page . Please move on to the next chapter to create and execute your first test case. Troubleshooting the Start You should first check if both VMs are up and running using the vagrant status command. You should see two VMs running: $ vagrant status Current machine states: r1 running (virtualbox) r2 running (virtualbox) If this is not the case, please try to re-execute the ./start-routers.sh script from above. If this still fails, please kill the VMs before trying again: $ vagrant destroy -f [...] $ ./start-routers.sh If both VMs show up as running , you should be able to ssh into them, using the vagrant ssh xx command (replacing xx by the router name, i.e. r1 or r2): [devnet@oli-test-w CLEUR20-CXTA]$ vagrant ssh r1 r1# You can then verify the connectivity between the two routers via the direct connection, for example by checking the routing adjacency (using show ip ospf neighbor ), you should see one neighbour: r1#show ip ospf neighbor Neighbor ID Pri State Dead Time Address Interface 10.0.0.2 1 FULL/BDR 00:00:38 172.16.0.2 GigabitEthernet2 r1# Use exit to exit from the device(s). Appendix: Sample Startup Output $ ./start-routers.sh Bringing machine 'r1' up with 'virtualbox' provider... ==> r1: Clearing any previously set forwarded ports... ==> r1: Clearing any previously set network interfaces... ==> r1: Preparing network interfaces based on configuration... r1: Adapter 1: nat r1: Adapter 2: intnet r1: Adapter 3: intnet ==> r1: Forwarding ports... r1: 830 (guest) => 2223 (host) (adapter 1) r1: 80 (guest) => 2224 (host) (adapter 1) r1: 443 (guest) => 2225 (host) (adapter 1) r1: 8443 (guest) => 2226 (host) (adapter 1) r1: 22 (guest) => 2222 (host) (adapter 1) ==> r1: Running 'pre-boot' VM customizations... ==> r1: Booting VM... ==> r1: Waiting for machine to boot. This may take a few minutes... r1: SSH address: 127.0.0.1:2222 r1: SSH username: vagrant r1: SSH auth method: private key ==> r1: Machine booted and ready! ==> r1: Checking for guest additions in VM... r1: No guest additions were detected on the base box for this VM! Guest r1: additions are required for forwarded ports, shared folders, host only r1: networking, and more. If SSH fails on this machine, please install r1: the guest additions and repackage the box to continue. r1: r1: This is not an error message; everything may continue to work properly, r1: in which case you may ignore this message. ==> r1: Machine already provisioned. Run `vagrant provision` or use the `--provision` ==> r1: flag to force provisioning. Provisioners marked to run always will still run. ==> r1: Machine 'r1' has a post `vagrant up` message. This is a message ==> r1: from the creator of the Vagrantfile, and not from Vagrant itself: ==> r1: ==> r1: ==> r1: Welcome to the IOS XE VirtualBox. ==> r1: To connect to the XE via ssh, use: 'vagrant ssh'. ==> r1: To ssh to XE's NETCONF or RESTCONF agent, use: ==> r1: 'vagrant port' (vagrant version > 1.8) ==> r1: to determine the port that maps to the guestport, ==> r1: ==> r1: The password for the vagrant user is vagrant ==> r1: ==> r1: IMPORTANT: READ CAREFULLY ==> r1: The Software is subject to and governed by the terms and conditions ==> r1: of the End User License Agreement and the Supplemental End User ==> r1: License Agreement accompanying the product, made available at the ==> r1: time of your order, or posted on the Cisco website at ==> r1: www.cisco.com/go/terms (collectively, the 'Agreement'). ==> r1: As set forth more fully in the Agreement, use of the Software is ==> r1: strictly limited to internal use in a non-production environment ==> r1: solely for demonstration and evaluation purposes. Downloading, ==> r1: installing, or using the Software constitutes acceptance of the ==> r1: Agreement, and you are binding yourself and the business entity ==> r1: that you represent to the Agreement. If you do not agree to all ==> r1: of the terms of the Agreement, then Cisco is unwilling to license ==> r1: the Software to you and (a) you may not download, install or use the ==> r1: Software, and (b) you may return the Software as more fully set forth ==> r1: in the Agreement. Bringing machine 'r2' up with 'virtualbox' provider... ==> r2: Clearing any previously set forwarded ports... ==> r2: Fixed port collision for 830 => 2223. Now on port 2200. ==> r2: Fixed port collision for 80 => 2224. Now on port 2201. ==> r2: Fixed port collision for 443 => 2225. Now on port 2202. ==> r2: Fixed port collision for 8443 => 2226. Now on port 2203. ==> r2: Fixed port collision for 22 => 2222. Now on port 2204. ==> r2: Clearing any previously set network interfaces... ==> r2: Preparing network interfaces based on configuration... r2: Adapter 1: nat r2: Adapter 2: intnet r2: Adapter 3: intnet ==> r2: Forwarding ports... r2: 830 (guest) => 2200 (host) (adapter 1) r2: 80 (guest) => 2201 (host) (adapter 1) r2: 443 (guest) => 2202 (host) (adapter 1) r2: 8443 (guest) => 2203 (host) (adapter 1) r2: 22 (guest) => 2204 (host) (adapter 1) ==> r2: Running 'pre-boot' VM customizations... ==> r2: Booting VM... ==> r2: Waiting for machine to boot. This may take a few minutes... r2: SSH address: 127.0.0.1:2204 r2: SSH username: vagrant r2: SSH auth method: private key ==> r2: Machine booted and ready! ==> r2: Checking for guest additions in VM... r2: No guest additions were detected on the base box for this VM! Guest r2: additions are required for forwarded ports, shared folders, host only r2: networking, and more. If SSH fails on this machine, please install r2: the guest additions and repackage the box to continue. r2: r2: This is not an error message; everything may continue to work properly, r2: in which case you may ignore this message. ==> r2: Machine already provisioned. Run `vagrant provision` or use the `--provision` ==> r2: flag to force provisioning. Provisioners marked to run always will still run. ==> r2: Machine 'r2' has a post `vagrant up` message. This is a message ==> r2: from the creator of the Vagrantfile, and not from Vagrant itself: ==> r2: ==> r2: ==> r2: Welcome to the IOS XE VirtualBox. ==> r2: To connect to the XE via ssh, use: 'vagrant ssh'. ==> r2: To ssh to XE's NETCONF or RESTCONF agent, use: ==> r2: 'vagrant port' (vagrant version > 1.8) ==> r2: to determine the port that maps to the guestport, ==> r2: ==> r2: The password for the vagrant user is vagrant ==> r2: ==> r2: IMPORTANT: READ CAREFULLY ==> r2: The Software is subject to and governed by the terms and conditions ==> r2: of the End User License Agreement and the Supplemental End User ==> r2: License Agreement accompanying the product, made available at the ==> r2: time of your order, or posted on the Cisco website at ==> r2: www.cisco.com/go/terms (collectively, the 'Agreement'). ==> r2: As set forth more fully in the Agreement, use of the Software is ==> r2: strictly limited to internal use in a non-production environment ==> r2: solely for demonstration and evaluation purposes. Downloading, ==> r2: installing, or using the Software constitutes acceptance of the ==> r2: Agreement, and you are binding yourself and the business entity ==> r2: that you represent to the Agreement. If you do not agree to all ==> r2: of the terms of the Agreement, then Cisco is unwilling to license ==> r2: the Software to you and (a) you may not download, install or use the ==> r2: Software, and (b) you may return the Software as more fully set forth ==> r2: in the Agreement. Setting up r1 r1#conf term Enter configuration commands, one per line. End with CNTL/Z. r1(config)#hostname r1 r1(config)#ipv6 unicast-routing r1(config)#no ip domain-lookup r1(config)#default interface Loopback0 Interface Loopback0 set to default configuration r1(config)#interface loopback0 r1(config-if)# ip address 10.0.0.1 255.255.255.255 r1(config-if)# ipv6 address fd00:0:0:0::1/128 r1(config-if)# ip ospf 1 area 0 r1(config-if)# ipv6 ospf 1 area 0 r1(config-if)#default interface GigabitEthernet2 Interface GigabitEthernet2 set to default configuration r1(config)#interface GigabitEthernet2 r1(config-if)# no shut r1(config-if)# ip address 172.16.0.1 255.255.255.0 r1(config-if)# ipv6 address fd00:a:a:a:2::1/64 r1(config-if)# ip ospf 1 area 0 r1(config-if)# ipv6 ospf 1 area 0 r1(config-if)#end r1#write Building configuration... [OK] r1#exit Connection to 127.0.0.1 closed by remote host. Setting up r2 r2#conf term Enter configuration commands, one per line. End with CNTL/Z. r2(config)#hostname r2 r2(config)#ipv6 unicast-routing r2(config)#no ip domain-lookup r2(config)#default interface Loopback0 Interface Loopback0 set to default configuration r2(config)#interface loopback0 r2(config-if)# ip address 10.0.0.2 255.255.255.255 r2(config-if)# ipv6 address fd00:0:0:0::2/128 r2(config-if)# ip ospf 1 area 0 r2(config-if)# ipv6 ospf 1 area 0 r2(config-if)#default interface GigabitEthernet2 Interface GigabitEthernet2 set to default configuration r2(config)#interface GigabitEthernet2 r2(config-if)# no shut r2(config-if)# ip address 172.16.0.2 255.255.255.0 r2(config-if)# ipv6 address fd00:a:a:a:2::2/64 r2(config-if)# ip ospf 1 area 0 r2(config-if)# ipv6 ospf 1 area 0 r2(config-if)#end r2#write Building configuration... [OK] r2#exit Connection to 127.0.0.1 closed by remote host. Setting up testbed.yaml r1, 127.0.0.1:2222, IdentityFile /home/devnet/.vagrant.d/insecure_private_key r2, 127.0.0.1:2204, IdentityFile /home/devnet/.vagrant.d/insecure_private_key starting cxta container Starting cxta_devnet ... done Starting cxta_docs ... done ============================================================================== Test-Vms ============================================================================== connect to all devices | PASS | Connected to ['r1', 'r2'] ------------------------------------------------------------------------------ Test-Vms | PASS | 1 critical test, 1 passed, 0 failed 1 test total, 1 passed, 0 failed ============================================================================== Output: /tmp/output.xml Log: /tmp/log.html Report: /tmp/report.html","title":"00 Setup"},{"location":"00-setup/#bringing-up-the-topology","text":"","title":"Bringing up the Topology"},{"location":"00-setup/#overview","text":"We have created a setup on this laptop you are sitting in front of which consists of a CXTA docker container containing the Python runtime environment to execute the tests two virtual IOS-XE devices which serve as units-under-test (UUT) The setup is depicted in the below diagram.","title":"Overview"},{"location":"00-setup/#start-the-environment","text":"To start the environment, please execute the following commands from your Linux shell: cd xxx/DEVWKS-1407 ./start-routers.sh This shell script performs the following tasks: It uses Vagrant to bring up the two IOS-XE virtual routers (using Virtualbox) Performs an initial configuration of the devices (essentially setting the hostname and configures IPv4/IPv6 on the link between the devices) Creates a testbed.yaml file which contains the device credentials and SSH ports to connect to the two virtual devices Starts the CXTA container (using docker-compose) As a final step, a Robot/CXTA test is run which verifies the basic connectivity. If all went well, the script output should end with below: ============================================================================== Test-Vms ============================================================================== connect to all devices | PASS | Connected to ['r1', 'r2'] ------------------------------------------------------------------------------ Test-Vms | PASS | 1 critical test, 1 passed, 0 failed 1 test total, 1 passed, 0 failed ============================================================================== If the test shows an error, it typically points to an issue bringing up the VM. Please refer to the next paragraph for some troubleshooting guidance. Please check for a full output of a working startup at the end of this page . Please move on to the next chapter to create and execute your first test case.","title":"Start the Environment"},{"location":"00-setup/#troubleshooting-the-start","text":"You should first check if both VMs are up and running using the vagrant status command. You should see two VMs running: $ vagrant status Current machine states: r1 running (virtualbox) r2 running (virtualbox) If this is not the case, please try to re-execute the ./start-routers.sh script from above. If this still fails, please kill the VMs before trying again: $ vagrant destroy -f [...] $ ./start-routers.sh If both VMs show up as running , you should be able to ssh into them, using the vagrant ssh xx command (replacing xx by the router name, i.e. r1 or r2): [devnet@oli-test-w CLEUR20-CXTA]$ vagrant ssh r1 r1# You can then verify the connectivity between the two routers via the direct connection, for example by checking the routing adjacency (using show ip ospf neighbor ), you should see one neighbour: r1#show ip ospf neighbor Neighbor ID Pri State Dead Time Address Interface 10.0.0.2 1 FULL/BDR 00:00:38 172.16.0.2 GigabitEthernet2 r1# Use exit to exit from the device(s).","title":"Troubleshooting the Start"},{"location":"00-setup/#appendix-sample-startup-output","text":"$ ./start-routers.sh Bringing machine 'r1' up with 'virtualbox' provider... ==> r1: Clearing any previously set forwarded ports... ==> r1: Clearing any previously set network interfaces... ==> r1: Preparing network interfaces based on configuration... r1: Adapter 1: nat r1: Adapter 2: intnet r1: Adapter 3: intnet ==> r1: Forwarding ports... r1: 830 (guest) => 2223 (host) (adapter 1) r1: 80 (guest) => 2224 (host) (adapter 1) r1: 443 (guest) => 2225 (host) (adapter 1) r1: 8443 (guest) => 2226 (host) (adapter 1) r1: 22 (guest) => 2222 (host) (adapter 1) ==> r1: Running 'pre-boot' VM customizations... ==> r1: Booting VM... ==> r1: Waiting for machine to boot. This may take a few minutes... r1: SSH address: 127.0.0.1:2222 r1: SSH username: vagrant r1: SSH auth method: private key ==> r1: Machine booted and ready! ==> r1: Checking for guest additions in VM... r1: No guest additions were detected on the base box for this VM! Guest r1: additions are required for forwarded ports, shared folders, host only r1: networking, and more. If SSH fails on this machine, please install r1: the guest additions and repackage the box to continue. r1: r1: This is not an error message; everything may continue to work properly, r1: in which case you may ignore this message. ==> r1: Machine already provisioned. Run `vagrant provision` or use the `--provision` ==> r1: flag to force provisioning. Provisioners marked to run always will still run. ==> r1: Machine 'r1' has a post `vagrant up` message. This is a message ==> r1: from the creator of the Vagrantfile, and not from Vagrant itself: ==> r1: ==> r1: ==> r1: Welcome to the IOS XE VirtualBox. ==> r1: To connect to the XE via ssh, use: 'vagrant ssh'. ==> r1: To ssh to XE's NETCONF or RESTCONF agent, use: ==> r1: 'vagrant port' (vagrant version > 1.8) ==> r1: to determine the port that maps to the guestport, ==> r1: ==> r1: The password for the vagrant user is vagrant ==> r1: ==> r1: IMPORTANT: READ CAREFULLY ==> r1: The Software is subject to and governed by the terms and conditions ==> r1: of the End User License Agreement and the Supplemental End User ==> r1: License Agreement accompanying the product, made available at the ==> r1: time of your order, or posted on the Cisco website at ==> r1: www.cisco.com/go/terms (collectively, the 'Agreement'). ==> r1: As set forth more fully in the Agreement, use of the Software is ==> r1: strictly limited to internal use in a non-production environment ==> r1: solely for demonstration and evaluation purposes. Downloading, ==> r1: installing, or using the Software constitutes acceptance of the ==> r1: Agreement, and you are binding yourself and the business entity ==> r1: that you represent to the Agreement. If you do not agree to all ==> r1: of the terms of the Agreement, then Cisco is unwilling to license ==> r1: the Software to you and (a) you may not download, install or use the ==> r1: Software, and (b) you may return the Software as more fully set forth ==> r1: in the Agreement. Bringing machine 'r2' up with 'virtualbox' provider... ==> r2: Clearing any previously set forwarded ports... ==> r2: Fixed port collision for 830 => 2223. Now on port 2200. ==> r2: Fixed port collision for 80 => 2224. Now on port 2201. ==> r2: Fixed port collision for 443 => 2225. Now on port 2202. ==> r2: Fixed port collision for 8443 => 2226. Now on port 2203. ==> r2: Fixed port collision for 22 => 2222. Now on port 2204. ==> r2: Clearing any previously set network interfaces... ==> r2: Preparing network interfaces based on configuration... r2: Adapter 1: nat r2: Adapter 2: intnet r2: Adapter 3: intnet ==> r2: Forwarding ports... r2: 830 (guest) => 2200 (host) (adapter 1) r2: 80 (guest) => 2201 (host) (adapter 1) r2: 443 (guest) => 2202 (host) (adapter 1) r2: 8443 (guest) => 2203 (host) (adapter 1) r2: 22 (guest) => 2204 (host) (adapter 1) ==> r2: Running 'pre-boot' VM customizations... ==> r2: Booting VM... ==> r2: Waiting for machine to boot. This may take a few minutes... r2: SSH address: 127.0.0.1:2204 r2: SSH username: vagrant r2: SSH auth method: private key ==> r2: Machine booted and ready! ==> r2: Checking for guest additions in VM... r2: No guest additions were detected on the base box for this VM! Guest r2: additions are required for forwarded ports, shared folders, host only r2: networking, and more. If SSH fails on this machine, please install r2: the guest additions and repackage the box to continue. r2: r2: This is not an error message; everything may continue to work properly, r2: in which case you may ignore this message. ==> r2: Machine already provisioned. Run `vagrant provision` or use the `--provision` ==> r2: flag to force provisioning. Provisioners marked to run always will still run. ==> r2: Machine 'r2' has a post `vagrant up` message. This is a message ==> r2: from the creator of the Vagrantfile, and not from Vagrant itself: ==> r2: ==> r2: ==> r2: Welcome to the IOS XE VirtualBox. ==> r2: To connect to the XE via ssh, use: 'vagrant ssh'. ==> r2: To ssh to XE's NETCONF or RESTCONF agent, use: ==> r2: 'vagrant port' (vagrant version > 1.8) ==> r2: to determine the port that maps to the guestport, ==> r2: ==> r2: The password for the vagrant user is vagrant ==> r2: ==> r2: IMPORTANT: READ CAREFULLY ==> r2: The Software is subject to and governed by the terms and conditions ==> r2: of the End User License Agreement and the Supplemental End User ==> r2: License Agreement accompanying the product, made available at the ==> r2: time of your order, or posted on the Cisco website at ==> r2: www.cisco.com/go/terms (collectively, the 'Agreement'). ==> r2: As set forth more fully in the Agreement, use of the Software is ==> r2: strictly limited to internal use in a non-production environment ==> r2: solely for demonstration and evaluation purposes. Downloading, ==> r2: installing, or using the Software constitutes acceptance of the ==> r2: Agreement, and you are binding yourself and the business entity ==> r2: that you represent to the Agreement. If you do not agree to all ==> r2: of the terms of the Agreement, then Cisco is unwilling to license ==> r2: the Software to you and (a) you may not download, install or use the ==> r2: Software, and (b) you may return the Software as more fully set forth ==> r2: in the Agreement. Setting up r1 r1#conf term Enter configuration commands, one per line. End with CNTL/Z. r1(config)#hostname r1 r1(config)#ipv6 unicast-routing r1(config)#no ip domain-lookup r1(config)#default interface Loopback0 Interface Loopback0 set to default configuration r1(config)#interface loopback0 r1(config-if)# ip address 10.0.0.1 255.255.255.255 r1(config-if)# ipv6 address fd00:0:0:0::1/128 r1(config-if)# ip ospf 1 area 0 r1(config-if)# ipv6 ospf 1 area 0 r1(config-if)#default interface GigabitEthernet2 Interface GigabitEthernet2 set to default configuration r1(config)#interface GigabitEthernet2 r1(config-if)# no shut r1(config-if)# ip address 172.16.0.1 255.255.255.0 r1(config-if)# ipv6 address fd00:a:a:a:2::1/64 r1(config-if)# ip ospf 1 area 0 r1(config-if)# ipv6 ospf 1 area 0 r1(config-if)#end r1#write Building configuration... [OK] r1#exit Connection to 127.0.0.1 closed by remote host. Setting up r2 r2#conf term Enter configuration commands, one per line. End with CNTL/Z. r2(config)#hostname r2 r2(config)#ipv6 unicast-routing r2(config)#no ip domain-lookup r2(config)#default interface Loopback0 Interface Loopback0 set to default configuration r2(config)#interface loopback0 r2(config-if)# ip address 10.0.0.2 255.255.255.255 r2(config-if)# ipv6 address fd00:0:0:0::2/128 r2(config-if)# ip ospf 1 area 0 r2(config-if)# ipv6 ospf 1 area 0 r2(config-if)#default interface GigabitEthernet2 Interface GigabitEthernet2 set to default configuration r2(config)#interface GigabitEthernet2 r2(config-if)# no shut r2(config-if)# ip address 172.16.0.2 255.255.255.0 r2(config-if)# ipv6 address fd00:a:a:a:2::2/64 r2(config-if)# ip ospf 1 area 0 r2(config-if)# ipv6 ospf 1 area 0 r2(config-if)#end r2#write Building configuration... [OK] r2#exit Connection to 127.0.0.1 closed by remote host. Setting up testbed.yaml r1, 127.0.0.1:2222, IdentityFile /home/devnet/.vagrant.d/insecure_private_key r2, 127.0.0.1:2204, IdentityFile /home/devnet/.vagrant.d/insecure_private_key starting cxta container Starting cxta_devnet ... done Starting cxta_docs ... done ============================================================================== Test-Vms ============================================================================== connect to all devices | PASS | Connected to ['r1', 'r2'] ------------------------------------------------------------------------------ Test-Vms | PASS | 1 critical test, 1 passed, 0 failed 1 test total, 1 passed, 0 failed ============================================================================== Output: /tmp/output.xml Log: /tmp/log.html Report: /tmp/report.html","title":"Appendix: Sample Startup Output"},{"location":"01-basic/","text":"Basic Tests This Chapter introduces you to some basic Robotframework fundamentals and generic device interaction keywords. Test Execution Environment The Robotframework and CXTA runtime environment is installed on a pre-built Container, which has been started in the previous chapter . The directory structure containing the scripts and tests has been mounted into the container (into /home/cisco/cxta), so you can create/edit and examine files on the Linux operating system on the host (in XXXX/DEVWKS-1407/CLEUR2020-CXTA), while the execution happens on the container. Open an interactive session on the container using the following command: docker exec -it cxta_devnet bash You will end up in the /home/cisco/cxta directory, and you can see all the files from the directory you started the environment from: root@14b56b5cc0ac:/home/cisco/cxta# ls 01-basic Makefile Vagrantfile docs site test-vms.robot 02-parsing README.md docker-compose.yml mkdocs.yml start-routers.sh testbed.yaml root@14b56b5cc0ac:/home/cisco/cxta# You notice a directory 01-basic , which contains the first test script we want to examine and execute: Your First Test Case Change to the 01-basic directory and examine the 01-test1.robot file contained therein: # cd 01-basic # cat 01-test1.robot *** Settings *** Library CXTA Resource cxta.robot *** Variables *** # Location of the auto-generated testbed.yaml file which contains device # credentials. Rather than just using \"../testbed.yaml\", which assumes # the execution directory is the current directory, we set it # relative to the directory this .robot file is in (${CURDIR}), which allows # us also to execute the test case from a different directory (for example from # the parent directory using robot 01-basic/) ${testbed} ${CURDIR}/../testbed.yaml *** Test Cases *** Load testbed and connect to devices use testbed \"${testbed}\" connect to device \"r1\" connect to device \"r2\" check version on r1 ${output}= execute \"show version\" on device \"r1\" Should Contain ${output} Cisco IOS XE Software, Version 16.09.01 check version on r2 ${output}= execute \"show version\" on device \"r2\" Should Contain ${output} Cisco IOS XE Software, Version 16.09.01 This file is a robotframework test file, and you notice different sections: the Settings section contains the libraries we want to load. For this lab, we are using the CXTA library and a set of libraries which are defined in the resource file cxta.robot . This file is bundled with the cxta libraries on the container, you can examine it via more /venv/lib/python3.6/site-packages/CXTA/robot/cxta.robot if you're interested. The Variables section allows you define variables which you can use in other sections of the file. Here we only define the ${testbed} variable which contains the location of the testbed.yaml file which contains the access information to the devices we'll be interacting with. The final Test Cases section contains the actual test cases we are executing when running this file. Robot (by default) executes each of the test cases in the order specified. A test case succeeds if all the steps within a test case succeed. Run the Test Case Let's run it, executing it via robot 01-test1.robot on the container: root@14b56b5cc0ac:/home/cisco/cxta/01-basic# robot 01-test1.robot ============================================================================== 01-Test1 ============================================================================== Load testbed and connect to devices | PASS | ------------------------------------------------------------------------------ check version on r1 | PASS | ------------------------------------------------------------------------------ check version on r2 | PASS | ------------------------------------------------------------------------------ 01-Test1 | PASS | 3 critical tests, 3 passed, 0 failed 3 tests total, 3 passed, 0 failed ============================================================================== Output: /home/cisco/cxta/01-basic/output.xml Log: /home/cisco/cxta/01-basic/log.html Report: /home/cisco/cxta/01-basic/report.html root@14b56b5cc0ac:/home/cisco/cxta/01-basic# Examine Robot Logfiles The console output from Robotframework is quite terse and doesn't provide much more information than pass/fail for each of the test cases executed. For more detailed reporting, as well as for troubleshooting in case things go wrong, you need to revert to additional files created by Robot (CXTA creates some more diagnostic files which we are not going to cover here): log.html is the most important log created and collects each test step including the device output and other diagnostic information report.html contains a high-level report which shows pass/fail of each test case output.xml contains essentially the same information as the former two files combined, however in structured XML format for automated post-processing Please open the log.html created in the directory XXXX/DEVWKS-1407/CLEUR2020-CXTA/01-basic folder on the laptop using a browser and click through the steps by expanding the test case steps (see below screenshot) Test Failures We suggest you repeat the test, but change the version value the ${output} is checked against in one of the \"check version on rX\" test cases, i.e. [...] check version on r1 ${output}= execute \"show version\" on device \"r1\" Should Contain ${output} Cisco IOS XE Software, Version 99999999 re-run the test, and re-examine the log.html created to see how robot highlights the error(s). Test Suite Setup/Teardown By default, Robot executes all tests within a test suite (the robot file above in our example). If the number of tests grows large, there might be situations where you only want to run a subset of cases. Robotframework supports this by limiting the test case execution by tags (not used here) or by name. Let's try this using the -t (or --test ) command line argument. Let's now run a test only checking r1's version: # robot -t \"check version on r1\" 01-test1.robot (you can also use wildcards, i.e. robot -t \"*r1\" 01-test1.robot would also work) You see the test failing: ============================================================================== 01-Test1 ============================================================================== check version on r1 | FAIL | AttributeError: 'NoneType' object has no attribute 'devices' ------------------------------------------------------------------------------ 01-Test1 | FAIL | 1 critical test, 0 passed, 1 failed 1 test total, 0 passed, 1 failed The error message is unfortunately not that obvious, but if you examine the full .robot file, the first test case (\"Load testbed and connect to devices\") is now skipped, which causes subsequent test cases which rely on the device connections to fail. This highlights a problem with the chosen approach (which we introduced for educational purposes ;-) ) as test cases are dependent on each other, which is something we should avoid as much as possible. To support test interdependency, Robotframework (like many other testing frameworks) support Setup and Teardown functions which can be executed before a test case starts (and after a test case finishes). These setup functions can also be specified at a test suite level, i.e. before the first test starts and after the last test finishes. We prepared a test suite utilizing this functionality in file 01-test2.robot: *** Settings *** Library CXTA Resource cxta.robot Suite Setup Load testbed and connect to devices *** Variables *** ${testbed} ${CURDIR}/../testbed.yaml *** Test Cases *** check version on r1 ${output}= execute \"show version\" on device \"r1\" Should Contain ${output} Cisco IOS XE Software, Version 16.09.01 check version on r2 ${output}= execute \"show version\" on device \"r2\" Should Contain ${output} Cisco IOS XE Software, Version 16.09.01 *** Keywords *** Load testbed and connect to devices use testbed \"${testbed}\" connect to device \"r1\" connect to device \"r2\" Comparing this to 01-test1.robot, you'll notice that the first test case (where we connect to the devices) has now moved into the Keywords section, this creating a new Robot keyword \"Load testbed and connect to devices\", which is now called as part of the Suite Setup , i.e. before the first test is executed. With this change, we can now selectively run any test case: # robot -t \"check version on r1\" 01-test2.robot ============================================================================== 01-Test2 ============================================================================== check version on r1 | PASS | ------------------------------------------------------------------------------ 01-Test2 | PASS | 1 critical test, 1 passed, 0 failed 1 test total, 1 passed, 0 failed [...] The console output only shows the test case executed, it doesn't show the Setup step, you need to revert to the log.html in the browser: What's next? Now that you have made yourself familiar with the environment and basic robot commands, let's move on to a more advanced use case which shows you the power of some of the CXTA and pyATS keywords.","title":"01 Basic Steps"},{"location":"01-basic/#basic-tests","text":"This Chapter introduces you to some basic Robotframework fundamentals and generic device interaction keywords.","title":"Basic Tests"},{"location":"01-basic/#test-execution-environment","text":"The Robotframework and CXTA runtime environment is installed on a pre-built Container, which has been started in the previous chapter . The directory structure containing the scripts and tests has been mounted into the container (into /home/cisco/cxta), so you can create/edit and examine files on the Linux operating system on the host (in XXXX/DEVWKS-1407/CLEUR2020-CXTA), while the execution happens on the container. Open an interactive session on the container using the following command: docker exec -it cxta_devnet bash You will end up in the /home/cisco/cxta directory, and you can see all the files from the directory you started the environment from: root@14b56b5cc0ac:/home/cisco/cxta# ls 01-basic Makefile Vagrantfile docs site test-vms.robot 02-parsing README.md docker-compose.yml mkdocs.yml start-routers.sh testbed.yaml root@14b56b5cc0ac:/home/cisco/cxta# You notice a directory 01-basic , which contains the first test script we want to examine and execute:","title":"Test Execution Environment"},{"location":"01-basic/#your-first-test-case","text":"Change to the 01-basic directory and examine the 01-test1.robot file contained therein: # cd 01-basic # cat 01-test1.robot *** Settings *** Library CXTA Resource cxta.robot *** Variables *** # Location of the auto-generated testbed.yaml file which contains device # credentials. Rather than just using \"../testbed.yaml\", which assumes # the execution directory is the current directory, we set it # relative to the directory this .robot file is in (${CURDIR}), which allows # us also to execute the test case from a different directory (for example from # the parent directory using robot 01-basic/) ${testbed} ${CURDIR}/../testbed.yaml *** Test Cases *** Load testbed and connect to devices use testbed \"${testbed}\" connect to device \"r1\" connect to device \"r2\" check version on r1 ${output}= execute \"show version\" on device \"r1\" Should Contain ${output} Cisco IOS XE Software, Version 16.09.01 check version on r2 ${output}= execute \"show version\" on device \"r2\" Should Contain ${output} Cisco IOS XE Software, Version 16.09.01 This file is a robotframework test file, and you notice different sections: the Settings section contains the libraries we want to load. For this lab, we are using the CXTA library and a set of libraries which are defined in the resource file cxta.robot . This file is bundled with the cxta libraries on the container, you can examine it via more /venv/lib/python3.6/site-packages/CXTA/robot/cxta.robot if you're interested. The Variables section allows you define variables which you can use in other sections of the file. Here we only define the ${testbed} variable which contains the location of the testbed.yaml file which contains the access information to the devices we'll be interacting with. The final Test Cases section contains the actual test cases we are executing when running this file. Robot (by default) executes each of the test cases in the order specified. A test case succeeds if all the steps within a test case succeed.","title":"Your First Test Case"},{"location":"01-basic/#run-the-test-case","text":"Let's run it, executing it via robot 01-test1.robot on the container: root@14b56b5cc0ac:/home/cisco/cxta/01-basic# robot 01-test1.robot ============================================================================== 01-Test1 ============================================================================== Load testbed and connect to devices | PASS | ------------------------------------------------------------------------------ check version on r1 | PASS | ------------------------------------------------------------------------------ check version on r2 | PASS | ------------------------------------------------------------------------------ 01-Test1 | PASS | 3 critical tests, 3 passed, 0 failed 3 tests total, 3 passed, 0 failed ============================================================================== Output: /home/cisco/cxta/01-basic/output.xml Log: /home/cisco/cxta/01-basic/log.html Report: /home/cisco/cxta/01-basic/report.html root@14b56b5cc0ac:/home/cisco/cxta/01-basic#","title":"Run the Test Case"},{"location":"01-basic/#examine-robot-logfiles","text":"The console output from Robotframework is quite terse and doesn't provide much more information than pass/fail for each of the test cases executed. For more detailed reporting, as well as for troubleshooting in case things go wrong, you need to revert to additional files created by Robot (CXTA creates some more diagnostic files which we are not going to cover here): log.html is the most important log created and collects each test step including the device output and other diagnostic information report.html contains a high-level report which shows pass/fail of each test case output.xml contains essentially the same information as the former two files combined, however in structured XML format for automated post-processing Please open the log.html created in the directory XXXX/DEVWKS-1407/CLEUR2020-CXTA/01-basic folder on the laptop using a browser and click through the steps by expanding the test case steps (see below screenshot)","title":"Examine Robot Logfiles"},{"location":"01-basic/#test-failures","text":"We suggest you repeat the test, but change the version value the ${output} is checked against in one of the \"check version on rX\" test cases, i.e. [...] check version on r1 ${output}= execute \"show version\" on device \"r1\" Should Contain ${output} Cisco IOS XE Software, Version 99999999 re-run the test, and re-examine the log.html created to see how robot highlights the error(s).","title":"Test Failures"},{"location":"01-basic/#test-suite-setupteardown","text":"By default, Robot executes all tests within a test suite (the robot file above in our example). If the number of tests grows large, there might be situations where you only want to run a subset of cases. Robotframework supports this by limiting the test case execution by tags (not used here) or by name. Let's try this using the -t (or --test ) command line argument. Let's now run a test only checking r1's version: # robot -t \"check version on r1\" 01-test1.robot (you can also use wildcards, i.e. robot -t \"*r1\" 01-test1.robot would also work) You see the test failing: ============================================================================== 01-Test1 ============================================================================== check version on r1 | FAIL | AttributeError: 'NoneType' object has no attribute 'devices' ------------------------------------------------------------------------------ 01-Test1 | FAIL | 1 critical test, 0 passed, 1 failed 1 test total, 0 passed, 1 failed The error message is unfortunately not that obvious, but if you examine the full .robot file, the first test case (\"Load testbed and connect to devices\") is now skipped, which causes subsequent test cases which rely on the device connections to fail. This highlights a problem with the chosen approach (which we introduced for educational purposes ;-) ) as test cases are dependent on each other, which is something we should avoid as much as possible. To support test interdependency, Robotframework (like many other testing frameworks) support Setup and Teardown functions which can be executed before a test case starts (and after a test case finishes). These setup functions can also be specified at a test suite level, i.e. before the first test starts and after the last test finishes. We prepared a test suite utilizing this functionality in file 01-test2.robot: *** Settings *** Library CXTA Resource cxta.robot Suite Setup Load testbed and connect to devices *** Variables *** ${testbed} ${CURDIR}/../testbed.yaml *** Test Cases *** check version on r1 ${output}= execute \"show version\" on device \"r1\" Should Contain ${output} Cisco IOS XE Software, Version 16.09.01 check version on r2 ${output}= execute \"show version\" on device \"r2\" Should Contain ${output} Cisco IOS XE Software, Version 16.09.01 *** Keywords *** Load testbed and connect to devices use testbed \"${testbed}\" connect to device \"r1\" connect to device \"r2\" Comparing this to 01-test1.robot, you'll notice that the first test case (where we connect to the devices) has now moved into the Keywords section, this creating a new Robot keyword \"Load testbed and connect to devices\", which is now called as part of the Suite Setup , i.e. before the first test is executed. With this change, we can now selectively run any test case: # robot -t \"check version on r1\" 01-test2.robot ============================================================================== 01-Test2 ============================================================================== check version on r1 | PASS | ------------------------------------------------------------------------------ 01-Test2 | PASS | 1 critical test, 1 passed, 0 failed 1 test total, 1 passed, 0 failed [...] The console output only shows the test case executed, it doesn't show the Setup step, you need to revert to the log.html in the browser:","title":"Test Suite Setup/Teardown"},{"location":"01-basic/#whats-next","text":"Now that you have made yourself familiar with the environment and basic robot commands, let's move on to a more advanced use case which shows you the power of some of the CXTA and pyATS keywords.","title":"What's next?"},{"location":"02-parsing/","text":"","title":"02 parsing"}]}